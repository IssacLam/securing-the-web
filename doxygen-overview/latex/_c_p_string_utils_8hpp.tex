\hypertarget{_c_p_string_utils_8hpp}{}\section{s2n-\/master/libcrypto-\/build/openssl/\+Mac\+O\+S/\+Get\+H\+T\+T\+PS.src/\+C\+P\+String\+Utils.hpp File Reference}
\label{_c_p_string_utils_8hpp}\index{s2n-\/master/libcrypto-\/build/openssl/\+Mac\+O\+S/\+Get\+H\+T\+T\+P\+S.\+src/\+C\+P\+String\+Utils.\+hpp@{s2n-\/master/libcrypto-\/build/openssl/\+Mac\+O\+S/\+Get\+H\+T\+T\+P\+S.\+src/\+C\+P\+String\+Utils.\+hpp}}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp__dep__incl}
\end{center}
\end{figure}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_aa3d21c3114a0a989f06c86d78d4d10c2}{Copy\+P\+Str\+To\+C\+Str} (const unsigned char $\ast$the\+P\+Str, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a9dfd1cd9c9ecb3673c3e87784724a011}{Copy\+P\+Str\+To\+P\+Str} (const unsigned char $\ast$the\+Src\+P\+Str, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a658e88bafe1cb451f10d3f01a7264359}{Copy\+C\+Str\+To\+C\+Str} (const char $\ast$the\+Src\+C\+Str, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a7f0f18d1bcacabcb386d67a202a62306}{Copy\+C\+Str\+To\+P\+Str} (const char $\ast$the\+Src\+C\+Str, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a44cd98d7de0fb90ebc4680ea29394a59}{Concat\+P\+Str\+To\+C\+Str} (const unsigned char $\ast$the\+P\+Str, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a198a30aee033bf3193b22c4997733e2f}{Concat\+P\+Str\+To\+P\+Str} (const unsigned char $\ast$the\+Src\+P\+Str, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_ad567dbf090e82e0cdfe9300c5f222966}{Concat\+C\+Str\+To\+P\+Str} (const char $\ast$the\+Src\+C\+Str, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a5a59076beb65283c27a32e2a441b83a5}{Concat\+C\+Str\+To\+C\+Str} (const char $\ast$the\+Src\+C\+Str, char $\ast$the\+Dst\+C\+Str, const int max\+C\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a2eeeb9886c6bd3f7029a695b132cda46}{Concat\+Char\+To\+C\+Str} (const char the\+Char, char $\ast$the\+Dst\+C\+Str, const int max\+C\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_ab53a3c6fc84d4434c15da179a0cd11f1}{Concat\+Char\+To\+P\+Str} (const char the\+Char, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+P\+Str\+Length)
\item 
int \hyperlink{_c_p_string_utils_8hpp_ae8fa5813c29e3a169649d4c936df48e5}{Compare\+P\+Strs} (const unsigned char $\ast$the\+First\+P\+Str, const unsigned char $\ast$the\+Second\+P\+Str, const Boolean ignore\+Case=true)
\item 
int \hyperlink{_c_p_string_utils_8hpp_a37f6b16c8163132d0cf8e6c41465f3d9}{Compare\+C\+Strs} (const char $\ast$the\+First\+C\+Str, const char $\ast$the\+Second\+C\+Str, const Boolean ignore\+Case=true)
\item 
int \hyperlink{_c_p_string_utils_8hpp_a2c03ff62793cc8c6e2f8dc64fc547278}{Compare\+C\+Str\+To\+P\+Str} (const char $\ast$the\+C\+Str, const unsigned char $\ast$the\+P\+Str, const Boolean ignore\+Case=true)
\item 
Boolean \hyperlink{_c_p_string_utils_8hpp_aaf40a097b6686f4f6a7f154b6bc4caa1}{C\+Strs\+Are\+Equal} (const char $\ast$the\+First\+C\+Str, const char $\ast$the\+Second\+C\+Str, const Boolean ignore\+Case=true)
\item 
Boolean \hyperlink{_c_p_string_utils_8hpp_aeb1e80b8fd78f6ee009f6e91bb117d79}{P\+Strs\+Are\+Equal} (const unsigned char $\ast$the\+First\+C\+Str, const unsigned char $\ast$the\+Second\+C\+Str, const Boolean ignore\+Case=true)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_ae3951b84f4eaf77fd9b9abbd5b95b776}{Copy\+Long\+Int\+To\+C\+Str} (const long the\+Num, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length, const int num\+Digits=-\/1)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_aee5570d9c70a0d64e2aa60900dae7fa3}{Copy\+Unsigned\+Long\+Int\+To\+C\+Str} (const unsigned long the\+Num, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a64e1d3d1c7820fa44990737ac7ad2092}{Concat\+Long\+Int\+To\+C\+Str} (const long the\+Num, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length, const int num\+Digits=-\/1)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a4e2365d621aafb89bbcfebd810b7df43}{Copy\+C\+Str\+And\+Concat\+Long\+Int\+To\+C\+Str} (const char $\ast$the\+Src\+C\+Str, const long the\+Num, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_ae7ec7fd0450bef6db8a04fdeb7188005}{Copy\+Long\+Int\+To\+P\+Str} (const long the\+Num, unsigned char $\ast$the\+P\+Str, const int max\+P\+Str\+Length, const int num\+Digits=-\/1)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a3f1c3ca8cd26c7c6b6214c6271ee4028}{Concat\+Long\+Int\+To\+P\+Str} (const long the\+Num, unsigned char $\ast$the\+P\+Str, const int max\+P\+Str\+Length, const int num\+Digits=-\/1)
\item 
long \hyperlink{_c_p_string_utils_8hpp_a7bfc8229791c1db249bbe38fbbc4cabf}{C\+Str\+Length} (const char $\ast$the\+C\+String)
\item 
long \hyperlink{_c_p_string_utils_8hpp_a8777f51d38bd32a8bc1b422f0dfbaf26}{P\+Str\+Length} (const unsigned char $\ast$the\+P\+String)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_a17298ac0cbc833e92e060af6205759e3}{Copy\+C\+Str\+To\+Existing\+Handle} (const char $\ast$the\+C\+String, Handle the\+Handle)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_a36a4cfe0d92feb38df9b222a0cd56d7d}{Copy\+Long\+Int\+To\+Existing\+Handle} (const long in\+The\+Long\+Int, Handle the\+Handle)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_aca7ebd368152c239cb4ca3876708ae83}{Copy\+C\+Str\+To\+New\+Handle} (const char $\ast$the\+C\+String, Handle $\ast$the\+Handle)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_a880111ae616a1551b6294802dbbef1fa}{Copy\+P\+Str\+To\+New\+Handle} (const unsigned char $\ast$the\+P\+String, Handle $\ast$the\+Handle)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_a4c4ba0a343f429d4fd4a1b7857f67de8}{Copy\+Long\+Int\+To\+New\+Handle} (const long in\+The\+Long\+Int, Handle $\ast$the\+Handle)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_a9b32e839b7ae85cfec09a99ccfd0383c}{Append\+C\+Str\+To\+Handle} (const char $\ast$the\+C\+String, Handle the\+Handle, long $\ast$current\+Length=nil, long $\ast$max\+Length=nil)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_a7784942e61324e5d726870b3a648c40c}{Append\+Chars\+To\+Handle} (const char $\ast$the\+Chars, const int num\+Chars, Handle the\+Handle, long $\ast$current\+Length=nil, long $\ast$max\+Length=nil)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_ada3a36e1dca388a31ef20508b4d71130}{Append\+P\+Str\+To\+Handle} (const unsigned char $\ast$the\+P\+String, Handle the\+Handle, long $\ast$current\+Length=nil)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_aa9b2aeca003a12bfdf8c4845bc6e94e6}{Append\+Long\+Int\+To\+Handle} (const long in\+The\+Long\+Int, Handle the\+Handle, long $\ast$current\+Length=nil)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a7b94ca1621d33746b4148de1a3fa7e09}{Zero\+Mem} (\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} $\ast$the\+Mem\+Ptr, const unsigned long num\+Bytes)
\item 
char $\ast$ \hyperlink{_c_p_string_utils_8hpp_ab2ff3b5fef54bdc960894a5c69085f63}{Find\+Char\+In\+C\+Str} (const char the\+Char, const char $\ast$the\+C\+String)
\item 
long \hyperlink{_c_p_string_utils_8hpp_acc01d7b45520285aef388331ed743a88}{Find\+Char\+Offset\+In\+C\+Str} (const char the\+Char, const char $\ast$the\+C\+String, const Boolean in\+Ignore\+Case=false)
\item 
long \hyperlink{_c_p_string_utils_8hpp_aac76bdf05636cdba87b25dc2aac6f844}{Find\+C\+Str\+Offset\+In\+C\+Str} (const char $\ast$the\+C\+Substring, const char $\ast$the\+C\+String, const Boolean in\+Ignore\+Case=false)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a807c6804e922fefe659d21f0ac10a751}{Copy\+C\+Substr\+To\+C\+Str} (const char $\ast$the\+Src\+C\+Str, const int max\+Chars\+To\+Copy, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a8e4ce194356b3d254d2bcfd5d3b607c9}{Copy\+C\+Substr\+To\+P\+Str} (const char $\ast$the\+Src\+C\+Str, const int max\+Chars\+To\+Copy, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a8c50fd913403a328088f63b57578fe7b}{Insert\+C\+Str\+Into\+C\+Str} (const char $\ast$the\+Src\+C\+Str, const int the\+Insertion\+Offset, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_ae91f36e64d41b4bf32c6d46d569f2feb}{Insert\+P\+Str\+Into\+C\+Str} (const unsigned char $\ast$the\+Src\+P\+Str, const int the\+Insertion\+Offset, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_a71817681721c895409e8e09007172670}{Insert\+C\+Str\+Into\+Handle} (const char $\ast$the\+C\+String, Handle the\+Handle, const long in\+Insert\+Offset)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a96bc4869588910b804299c11aa72002c}{Copy\+C\+Str\+And\+Insert\+C\+Str\+Into\+C\+Str} (const char $\ast$the\+Src\+C\+Str, const char $\ast$the\+Insert\+C\+Str, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a8faf2025c36ae073f7eadea962f29e6c}{Copy\+C\+Str\+And\+Insert\+C\+Strs\+Long\+Ints\+Into\+C\+Str} (const char $\ast$the\+Src\+C\+Str, const char $\ast$$\ast$the\+Insert\+C\+Strs, const long $\ast$the\+Long\+Ints, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a8c2ed6654006f1f60df943b042531f84}{Copy\+C\+Str\+And\+Insert1\+Long\+Int\+Into\+C\+Str} (const char $\ast$the\+Src\+C\+Str, const long the\+Num, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_ae71298d0eefdc9e0b010f466235aa6a3}{Copy\+C\+Str\+And\+Insert2\+Long\+Ints\+Into\+C\+Str} (const char $\ast$the\+Src\+C\+Str, const long long1, const long long2, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a949beaa3c9fad8df4f8f23e619299d65}{Copy\+C\+Str\+And\+Insert3\+Long\+Ints\+Into\+C\+Str} (const char $\ast$the\+Src\+C\+Str, const long long1, const long long2, const long long3, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_adaef1a07385d214d2f78f5a795219dd8}{Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+C\+Str} (const char $\ast$the\+Src\+C\+Str, const char $\ast$the\+Insert\+C\+Str, const long the\+Num, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_a53398520bce3e6afc7fcbb1be7cd0ce7}{Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+Handle} (const char $\ast$the\+Src\+C\+Str, const char $\ast$the\+Insert\+C\+Str, const long the\+Num, Handle $\ast$the\+Handle)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_ab44cd05a83904b88ce29f11d96d37e39}{Copy\+Indexed\+Word\+To\+C\+Str} (char $\ast$the\+Src\+C\+Str, int which\+Word, char $\ast$the\+Dst\+C\+Str, int max\+Dst\+C\+Str\+Length)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_ac3c7882205f1aee48563a7b7722b19d2}{Copy\+Indexed\+Word\+To\+New\+Handle} (char $\ast$the\+Src\+C\+Str, int which\+Word, Handle $\ast$out\+The\+Handle)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_abcbf635e0435f9af4c79150131521182}{Copy\+Indexed\+Line\+To\+C\+Str} (const char $\ast$the\+Src\+C\+Str, int in\+Which\+Line, int $\ast$line\+End\+Index, Boolean $\ast$got\+Last\+Line, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+C\+Str\+Length)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_af904acf8af4f5a77913912abde9d7a90}{Copy\+Indexed\+Line\+To\+New\+Handle} (const char $\ast$the\+Src\+C\+Str, int in\+Which\+Line, Handle $\ast$out\+New\+Handle)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_a4190f68902f612fc26f82a3e112f7346}{Extract\+Int\+From\+C\+Str} (const char $\ast$the\+Src\+C\+Str, int $\ast$out\+Int, Boolean skip\+Leading\+Spaces=true)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_aaea0259b4d9390434101fde8d2e91ac7}{Extract\+Int\+From\+P\+Str} (const unsigned char $\ast$the\+Src\+P\+Str, int $\ast$out\+Int, Boolean skip\+Leading\+Spaces=true)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_aa5d5794d7ab06d3213420553a445fd96}{Convert\+C\+Str\+To\+Upper\+Case} (char $\ast$the\+Src\+C\+Str)
\item 
int \hyperlink{_c_p_string_utils_8hpp_abb80d5287721e3f8a2489ea5a654e807}{Count\+Occurences\+Of\+Char\+In\+C\+Str} (const char in\+Char, const char $\ast$in\+Src\+C\+Str)
\item 
int \hyperlink{_c_p_string_utils_8hpp_a0f0ac60c0dcb10ca46d7db923d0bc1a7}{Count\+Words\+In\+C\+Str} (const char $\ast$in\+Src\+C\+Str)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_aad874ee4f97a91280c4c448966b44655}{Count\+Digits} (const char $\ast$in\+C\+Str, int $\ast$out\+Num\+Integer\+Digits, int $\ast$out\+Num\+Fract\+Digits)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a6021ef8ab42d6c0c19a952877372c628}{Extract\+C\+Str\+Item\+From\+C\+Str} (const char $\ast$in\+Src\+C\+Str, const char in\+Item\+Delimiter, const int in\+Item\+Number, Boolean $\ast$found\+Item, char $\ast$out\+Dst\+Char\+Ptr, const int in\+Dst\+Char\+Ptr\+Max\+Length, const Boolean in\+Treat\+Multiple\+Delims\+As\+Single\+Delim=false)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_ac077bf309a36ead01c50a622b2fb8a44}{Extract\+C\+Str\+Item\+From\+C\+Str\+Into\+New\+Handle} (const char $\ast$in\+Src\+C\+Str, const char in\+Item\+Delimiter, const int in\+Item\+Number, Boolean $\ast$found\+Item, Handle $\ast$out\+New\+Handle, const Boolean in\+Treat\+Multiple\+Delims\+As\+Single\+Delim=false)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_a68689b7b415bcd3ddad4f1185a0255e0}{Extract\+Float\+From\+C\+Str} (const char $\ast$in\+C\+String, extended80 $\ast$out\+Float)
\item 
O\+S\+Err \hyperlink{_c_p_string_utils_8hpp_a3309362121ed5ada320dc570bd2315da}{Copy\+Float\+To\+C\+Str} (const extended80 $\ast$the\+Float, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length, const int in\+Max\+Num\+Int\+Digits=-\/1, const int in\+Max\+Num\+Fract\+Digits=-\/1)
\item 
\hyperlink{hw__4758__cca_8h_afad4d591c7931ff6dc5bf69c76c96aa0}{void} \hyperlink{_c_p_string_utils_8hpp_a91dd2516988dceadf856069043cb904e}{Skip\+White\+Space} (char $\ast$$\ast$io\+Src\+Char\+Ptr, const Boolean in\+Stop\+At\+E\+OL=false)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+P\+Str\+To\+C\+Str@{Copy\+P\+Str\+To\+C\+Str}}
\index{Copy\+P\+Str\+To\+C\+Str@{Copy\+P\+Str\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+P\+Str\+To\+C\+Str(const unsigned char $\ast$the\+P\+Str, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length)}{CopyPStrToCStr(const unsigned char *thePStr, char *theCStr, const int maxCStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+P\+Str\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const unsigned char $\ast$}]{the\+P\+Str, }
\item[{char $\ast$}]{the\+C\+Str, }
\item[{const int}]{max\+C\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_aa3d21c3114a0a989f06c86d78d4d10c2}{}\label{_c_p_string_utils_8hpp_aa3d21c3114a0a989f06c86d78d4d10c2}


Definition at line 69 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
70 \{
71 \textcolor{keywordtype}{int}     i,numPChars;
72 
73 
74     \textcolor{keywordflow}{if} (thePStr != nil && theCStr != nil && maxCStrLength > 0)
75     \{
76         numPChars = thePStr[0];
77         
78         \textcolor{keywordflow}{for} (i = 0;;i++)
79         \{
80             \textcolor{keywordflow}{if} (i >= numPChars || i >= maxCStrLength - 1)
81             \{
82                 theCStr[i] = 0;
83                 
84                 \textcolor{keywordflow}{break};
85             \}
86             
87             \textcolor{keywordflow}{else}
88             \{
89                 theCStr[i] = thePStr[i + 1];
90             \}
91         \}
92     \}
93 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_aa3d21c3114a0a989f06c86d78d4d10c2_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+P\+Str\+To\+P\+Str@{Copy\+P\+Str\+To\+P\+Str}}
\index{Copy\+P\+Str\+To\+P\+Str@{Copy\+P\+Str\+To\+P\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+P\+Str\+To\+P\+Str(const unsigned char $\ast$the\+Src\+P\+Str, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+Dst\+Str\+Length)}{CopyPStrToPStr(const unsigned char *theSrcPStr, unsigned char *theDstPStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+P\+Str\+To\+P\+Str (
\begin{DoxyParamCaption}
\item[{const unsigned char $\ast$}]{the\+Src\+P\+Str, }
\item[{unsigned char $\ast$}]{the\+Dst\+P\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a9dfd1cd9c9ecb3673c3e87784724a011}{}\label{_c_p_string_utils_8hpp_a9dfd1cd9c9ecb3673c3e87784724a011}


Definition at line 96 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
97 \{
98 \textcolor{keywordtype}{int}     theMaxDstStrLength;
99 
100     
101     theMaxDstStrLength = maxDstStrLength;
102     
103     
104     \textcolor{keywordflow}{if} (theDstPStr != nil && theSrcPStr != nil && theMaxDstStrLength > 0)
105     \{
106         \textcolor{keywordflow}{if} (theMaxDstStrLength > 255)
107         \{
108             theMaxDstStrLength = 255;
109         \}
110         
111         
112         \textcolor{keywordflow}{if} (theMaxDstStrLength - 1 < theSrcPStr[0])
113         \{
114             BlockMove(theSrcPStr + 1,theDstPStr + 1,theMaxDstStrLength - 1);
115             
116             theDstPStr[0] = theMaxDstStrLength - 1;
117         \}
118         
119         \textcolor{keywordflow}{else}
120         \{
121             BlockMove(theSrcPStr,theDstPStr,theSrcPStr[0] + 1);
122         \}
123     \}
124 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+To\+C\+Str@{Copy\+C\+Str\+To\+C\+Str}}
\index{Copy\+C\+Str\+To\+C\+Str@{Copy\+C\+Str\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+To\+C\+Str(const char $\ast$the\+Src\+C\+Str, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)}{CopyCStrToCStr(const char *theSrcCStr, char *theDstCStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+C\+Str\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a658e88bafe1cb451f10d3f01a7264359}{}\label{_c_p_string_utils_8hpp_a658e88bafe1cb451f10d3f01a7264359}


Definition at line 127 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
128 \{
129 \textcolor{keywordtype}{int}     i;
130 
131 
132     \textcolor{keywordflow}{if} (theDstCStr != nil && theSrcCStr != nil && maxDstStrLength > 0)
133     \{
134         \textcolor{keywordflow}{for} (i = 0;;i++)
135         \{
136             \textcolor{keywordflow}{if} (theSrcCStr[i] == 0 || i >= maxDstStrLength - 1)
137             \{
138                 theDstCStr[i] = 0;
139                 
140                 \textcolor{keywordflow}{break};
141             \}
142             
143             \textcolor{keywordflow}{else}
144             \{
145                 theDstCStr[i] = theSrcCStr[i];
146             \}
147         \}
148     \}
149 \}
\end{DoxyCode}


Here is the caller graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a658e88bafe1cb451f10d3f01a7264359_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+To\+P\+Str@{Copy\+C\+Str\+To\+P\+Str}}
\index{Copy\+C\+Str\+To\+P\+Str@{Copy\+C\+Str\+To\+P\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+To\+P\+Str(const char $\ast$the\+Src\+C\+Str, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+Dst\+Str\+Length)}{CopyCStrToPStr(const char *theSrcCStr, unsigned char *theDstPStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+C\+Str\+To\+P\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{unsigned char $\ast$}]{the\+Dst\+P\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a7f0f18d1bcacabcb386d67a202a62306}{}\label{_c_p_string_utils_8hpp_a7f0f18d1bcacabcb386d67a202a62306}


Definition at line 214 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
215 \{
216 \textcolor{keywordtype}{int}     i;
217 \textcolor{keywordtype}{int}     theMaxDstStrLength;
218 
219     
220     theMaxDstStrLength = maxDstStrLength;
221 
222     \textcolor{keywordflow}{if} (theDstPStr != nil && theSrcCStr != nil && theMaxDstStrLength > 0)
223     \{
224         \textcolor{keywordflow}{if} (theMaxDstStrLength > 255)
225         \{
226             theMaxDstStrLength = 255;
227         \}
228         
229         
230         \textcolor{keywordflow}{for} (i = 0;;i++)
231         \{
232             \textcolor{keywordflow}{if} (i >= theMaxDstStrLength - 1 || theSrcCStr[i] == 0)
233             \{
234                 theDstPStr[0] = i;
235                 
236                 \textcolor{keywordflow}{break};
237             \}
238             
239             \textcolor{keywordflow}{else}
240             \{
241                 theDstPStr[i + 1] = theSrcCStr[i];
242             \}
243         \}
244     \}
245 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a7f0f18d1bcacabcb386d67a202a62306_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Concat\+P\+Str\+To\+C\+Str@{Concat\+P\+Str\+To\+C\+Str}}
\index{Concat\+P\+Str\+To\+C\+Str@{Concat\+P\+Str\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Concat\+P\+Str\+To\+C\+Str(const unsigned char $\ast$the\+P\+Str, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length)}{ConcatPStrToCStr(const unsigned char *thePStr, char *theCStr, const int maxCStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Concat\+P\+Str\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const unsigned char $\ast$}]{the\+P\+Str, }
\item[{char $\ast$}]{the\+C\+Str, }
\item[{const int}]{max\+C\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a44cd98d7de0fb90ebc4680ea29394a59}{}\label{_c_p_string_utils_8hpp_a44cd98d7de0fb90ebc4680ea29394a59}


Definition at line 248 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
249 \{
250 \textcolor{keywordtype}{int}     i,numPChars,cStrLength;
251 
252 
253     \textcolor{keywordflow}{if} (thePStr != nil && theCStr != nil && maxCStrLength > 0)
254     \{
255         \textcolor{keywordflow}{for} (cStrLength = 0;theCStr[cStrLength] != 0;cStrLength++)
256         \{
257         
258         \}
259         
260 
261         numPChars = thePStr[0];
262         
263         
264         \textcolor{keywordflow}{for} (i = 0;;i++)
265         \{
266             \textcolor{keywordflow}{if} (i >= numPChars || cStrLength >= maxCStrLength - 1)
267             \{
268                 theCStr[cStrLength++] = 0;
269                 
270                 \textcolor{keywordflow}{break};
271             \}
272             
273             \textcolor{keywordflow}{else}
274             \{
275                 theCStr[cStrLength++] = thePStr[i + 1];
276             \}
277         \}
278     \}
279 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a44cd98d7de0fb90ebc4680ea29394a59_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Concat\+P\+Str\+To\+P\+Str@{Concat\+P\+Str\+To\+P\+Str}}
\index{Concat\+P\+Str\+To\+P\+Str@{Concat\+P\+Str\+To\+P\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Concat\+P\+Str\+To\+P\+Str(const unsigned char $\ast$the\+Src\+P\+Str, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+Dst\+Str\+Length)}{ConcatPStrToPStr(const unsigned char *theSrcPStr, unsigned char *theDstPStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Concat\+P\+Str\+To\+P\+Str (
\begin{DoxyParamCaption}
\item[{const unsigned char $\ast$}]{the\+Src\+P\+Str, }
\item[{unsigned char $\ast$}]{the\+Dst\+P\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a198a30aee033bf3193b22c4997733e2f}{}\label{_c_p_string_utils_8hpp_a198a30aee033bf3193b22c4997733e2f}


Definition at line 283 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
284 \{
285 \textcolor{keywordtype}{int}     theMaxDstStrLength;
286 
287     
288     theMaxDstStrLength = maxDstStrLength;
289     
290     \textcolor{keywordflow}{if} (theSrcPStr != nil && theDstPStr != nil && theMaxDstStrLength > 0)
291     \{
292         \textcolor{keywordflow}{if} (theMaxDstStrLength > 255)
293         \{
294             theMaxDstStrLength = 255;
295         \}
296         
297         
298         \textcolor{keywordflow}{if} (theMaxDstStrLength - theDstPStr[0] - 1 < theSrcPStr[0])
299         \{
300             BlockMove(theSrcPStr + 1,theDstPStr + theDstPStr[0] + 1,theMaxDstStrLength - 1 - theDstPStr[0])
      ;
301             
302             theDstPStr[0] = theMaxDstStrLength - 1;
303         \}
304         
305         \textcolor{keywordflow}{else}
306         \{
307             BlockMove(theSrcPStr + 1,theDstPStr + theDstPStr[0] + 1,theSrcPStr[0]);
308             
309             theDstPStr[0] += theSrcPStr[0];
310         \}
311     \}
312 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=324pt]{_c_p_string_utils_8hpp_a198a30aee033bf3193b22c4997733e2f_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Concat\+C\+Str\+To\+P\+Str@{Concat\+C\+Str\+To\+P\+Str}}
\index{Concat\+C\+Str\+To\+P\+Str@{Concat\+C\+Str\+To\+P\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Concat\+C\+Str\+To\+P\+Str(const char $\ast$the\+Src\+C\+Str, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+Dst\+Str\+Length)}{ConcatCStrToPStr(const char *theSrcCStr, unsigned char *theDstPStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Concat\+C\+Str\+To\+P\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{unsigned char $\ast$}]{the\+Dst\+P\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ad567dbf090e82e0cdfe9300c5f222966}{}\label{_c_p_string_utils_8hpp_ad567dbf090e82e0cdfe9300c5f222966}


Definition at line 316 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
317 \{
318 \textcolor{keywordtype}{int}     i,thePStrLength;
319 \textcolor{keywordtype}{int}     theMaxDstStrLength;
320 
321     
322     theMaxDstStrLength = maxDstStrLength;
323 
324     \textcolor{keywordflow}{if} (theSrcCStr != nil && theDstPStr != nil && theMaxDstStrLength > 0)
325     \{
326         \textcolor{keywordflow}{if} (theMaxDstStrLength > 255)
327         \{
328             theMaxDstStrLength = 255;
329         \}
330         
331         
332         thePStrLength = theDstPStr[0];
333         
334         \textcolor{keywordflow}{for} (i = 0;;i++)
335         \{
336             \textcolor{keywordflow}{if} (theSrcCStr[i] == 0 || thePStrLength >= theMaxDstStrLength - 1)
337             \{
338                 theDstPStr[0] = thePStrLength;
339                 
340                 \textcolor{keywordflow}{break};
341             \}
342             
343             \textcolor{keywordflow}{else}
344             \{
345                 theDstPStr[thePStrLength + 1] = theSrcCStr[i];
346                 
347                 thePStrLength++;
348             \}
349         \}
350     \}
351 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Concat\+C\+Str\+To\+C\+Str@{Concat\+C\+Str\+To\+C\+Str}}
\index{Concat\+C\+Str\+To\+C\+Str@{Concat\+C\+Str\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Concat\+C\+Str\+To\+C\+Str(const char $\ast$the\+Src\+C\+Str, char $\ast$the\+Dst\+C\+Str, const int max\+C\+Str\+Length)}{ConcatCStrToCStr(const char *theSrcCStr, char *theDstCStr, const int maxCStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Concat\+C\+Str\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+C\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a5a59076beb65283c27a32e2a441b83a5}{}\label{_c_p_string_utils_8hpp_a5a59076beb65283c27a32e2a441b83a5}


Definition at line 355 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
356 \{
357 \textcolor{keywordtype}{int}     cStrLength;
358 
359 
360     \textcolor{keywordflow}{if} (theSrcCStr != nil && theDstCStr != nil && maxCStrLength > 0)
361     \{
362         \textcolor{keywordflow}{for} (cStrLength = 0;theDstCStr[cStrLength] != 0;cStrLength++)
363         \{
364         
365         \}
366         
367 
368         \textcolor{keywordflow}{for} (;;)
369         \{
370             \textcolor{keywordflow}{if} (*theSrcCStr == 0 || cStrLength >= maxCStrLength - 1)
371             \{
372                 theDstCStr[cStrLength++] = 0;
373                 
374                 \textcolor{keywordflow}{break};
375             \}
376             
377             \textcolor{keywordflow}{else}
378             \{
379                 theDstCStr[cStrLength++] = *theSrcCStr++;
380             \}
381         \}
382     \}
383 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a5a59076beb65283c27a32e2a441b83a5_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Concat\+Char\+To\+C\+Str@{Concat\+Char\+To\+C\+Str}}
\index{Concat\+Char\+To\+C\+Str@{Concat\+Char\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Concat\+Char\+To\+C\+Str(const char the\+Char, char $\ast$the\+Dst\+C\+Str, const int max\+C\+Str\+Length)}{ConcatCharToCStr(const char theChar, char *theDstCStr, const int maxCStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Concat\+Char\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char}]{the\+Char, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+C\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a2eeeb9886c6bd3f7029a695b132cda46}{}\label{_c_p_string_utils_8hpp_a2eeeb9886c6bd3f7029a695b132cda46}


Definition at line 387 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
388 \{
389 \textcolor{keywordtype}{int}     cStrLength;
390 
391 
392     \textcolor{keywordflow}{if} (theDstCStr != nil && maxCStrLength > 0)
393     \{
394         cStrLength = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theDstCStr);
395         
396         \textcolor{keywordflow}{if} (cStrLength < maxCStrLength - 1)
397         \{
398             theDstCStr[cStrLength++] = theChar;
399             theDstCStr[cStrLength++] = \textcolor{charliteral}{'\(\backslash\)0'};
400         \}
401     \}
402 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=283pt]{_c_p_string_utils_8hpp_a2eeeb9886c6bd3f7029a695b132cda46_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Concat\+Char\+To\+P\+Str@{Concat\+Char\+To\+P\+Str}}
\index{Concat\+Char\+To\+P\+Str@{Concat\+Char\+To\+P\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Concat\+Char\+To\+P\+Str(const char the\+Char, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+P\+Str\+Length)}{ConcatCharToPStr(const char theChar, unsigned char *theDstPStr, const int maxPStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Concat\+Char\+To\+P\+Str (
\begin{DoxyParamCaption}
\item[{const char}]{the\+Char, }
\item[{unsigned char $\ast$}]{the\+Dst\+P\+Str, }
\item[{const int}]{max\+P\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ab53a3c6fc84d4434c15da179a0cd11f1}{}\label{_c_p_string_utils_8hpp_ab53a3c6fc84d4434c15da179a0cd11f1}


Definition at line 406 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
407 \{
408 \textcolor{keywordtype}{int}     pStrLength;
409 
410 
411     \textcolor{keywordflow}{if} (theDstPStr != nil && maxPStrLength > 0)
412     \{
413         pStrLength = \hyperlink{_c_p_string_utils_8cpp_a8777f51d38bd32a8bc1b422f0dfbaf26}{PStrLength}(theDstPStr);
414         
415         \textcolor{keywordflow}{if} (pStrLength < maxPStrLength - 1 && pStrLength < 255)
416         \{
417             theDstPStr[pStrLength + 1] = theChar;
418             theDstPStr[0] += 1;
419         \}
420     \}
421 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=281pt]{_c_p_string_utils_8hpp_ab53a3c6fc84d4434c15da179a0cd11f1_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Compare\+P\+Strs@{Compare\+P\+Strs}}
\index{Compare\+P\+Strs@{Compare\+P\+Strs}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Compare\+P\+Strs(const unsigned char $\ast$the\+First\+P\+Str, const unsigned char $\ast$the\+Second\+P\+Str, const Boolean ignore\+Case=true)}{ComparePStrs(const unsigned char *theFirstPStr, const unsigned char *theSecondPStr, const Boolean ignoreCase=true)}}]{\setlength{\rightskip}{0pt plus 5cm}int Compare\+P\+Strs (
\begin{DoxyParamCaption}
\item[{const unsigned char $\ast$}]{the\+First\+P\+Str, }
\item[{const unsigned char $\ast$}]{the\+Second\+P\+Str, }
\item[{const Boolean}]{ignore\+Case = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ae8fa5813c29e3a169649d4c936df48e5}{}\label{_c_p_string_utils_8hpp_ae8fa5813c29e3a169649d4c936df48e5}


Definition at line 531 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
532 \{
533 \textcolor{keywordtype}{int}     i,returnValue;
534 \textcolor{keywordtype}{char}    firstChar,secondChar;
535 
536     
537     returnValue = 0;
538     
539     
540     \textcolor{keywordflow}{if} (theFirstPStr != nil && theSecondPStr != nil)
541     \{
542         \textcolor{keywordflow}{for} (i = 1;;i++)
543         \{
544             firstChar = theFirstPStr[i];
545             secondChar = theSecondPStr[i];
546 
547             \textcolor{keywordflow}{if} (ignoreCase == \textcolor{keyword}{true})
548             \{
549                 \textcolor{keywordflow}{if} (firstChar >= \textcolor{charliteral}{'A'} && firstChar <= \textcolor{charliteral}{'Z'})
550                 \{
551                     firstChar = \textcolor{charliteral}{'a'} + (firstChar - \textcolor{charliteral}{'A'});
552                 \}
553                 
554                 \textcolor{keywordflow}{if} (secondChar >= \textcolor{charliteral}{'A'} && secondChar <= \textcolor{charliteral}{'Z'})
555                 \{
556                     secondChar = \textcolor{charliteral}{'a'} + (secondChar - \textcolor{charliteral}{'A'});
557                 \}
558             \}
559 
560 
561             \textcolor{keywordflow}{if} (theFirstPStr[0] < i && theSecondPStr[0] >= i)
562             \{
563                 returnValue = -1;
564                 
565                 \textcolor{keywordflow}{break};
566             \}
567             
568             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (theFirstPStr[0] >= i && theSecondPStr[0] < i)
569             \{
570                 returnValue = 1;
571                 
572                 \textcolor{keywordflow}{break};
573             \}
574             
575             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (theFirstPStr[0] < i && theSecondPStr[0] < i)
576             \{
577                 returnValue = 0;
578                 
579                 \textcolor{keywordflow}{break};
580             \}
581             
582             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (firstChar < secondChar)
583             \{
584                 returnValue = -1;
585                 
586                 \textcolor{keywordflow}{break};
587             \}
588             
589             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (firstChar > secondChar)
590             \{
591                 returnValue = 1;
592                 
593                 \textcolor{keywordflow}{break};
594             \}
595         \}
596     \}
597     
598     
599     \textcolor{keywordflow}{return}(returnValue);
600 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=279pt]{_c_p_string_utils_8hpp_ae8fa5813c29e3a169649d4c936df48e5_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Compare\+C\+Strs@{Compare\+C\+Strs}}
\index{Compare\+C\+Strs@{Compare\+C\+Strs}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Compare\+C\+Strs(const char $\ast$the\+First\+C\+Str, const char $\ast$the\+Second\+C\+Str, const Boolean ignore\+Case=true)}{CompareCStrs(const char *theFirstCStr, const char *theSecondCStr, const Boolean ignoreCase=true)}}]{\setlength{\rightskip}{0pt plus 5cm}int Compare\+C\+Strs (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+First\+C\+Str, }
\item[{const char $\ast$}]{the\+Second\+C\+Str, }
\item[{const Boolean}]{ignore\+Case = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a37f6b16c8163132d0cf8e6c41465f3d9}{}\label{_c_p_string_utils_8hpp_a37f6b16c8163132d0cf8e6c41465f3d9}


Definition at line 426 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
427 \{
428 \textcolor{keywordtype}{int}     returnValue;
429 \textcolor{keywordtype}{char}    firstChar,secondChar;
430 
431     
432     returnValue = 0;
433     
434     
435     \textcolor{keywordflow}{if} (theFirstCStr != nil && theSecondCStr != nil)
436     \{
437         \textcolor{keywordflow}{for} (;;)
438         \{
439             firstChar = *theFirstCStr;
440             secondChar = *theSecondCStr;
441             
442             \textcolor{keywordflow}{if} (ignoreCase == \textcolor{keyword}{true})
443             \{
444                 \textcolor{keywordflow}{if} (firstChar >= \textcolor{charliteral}{'A'} && firstChar <= \textcolor{charliteral}{'Z'})
445                 \{
446                     firstChar = \textcolor{charliteral}{'a'} + (firstChar - \textcolor{charliteral}{'A'});
447                 \}
448                 
449                 \textcolor{keywordflow}{if} (secondChar >= \textcolor{charliteral}{'A'} && secondChar <= \textcolor{charliteral}{'Z'})
450                 \{
451                     secondChar = \textcolor{charliteral}{'a'} + (secondChar - \textcolor{charliteral}{'A'});
452                 \}
453             \}
454             
455             
456             \textcolor{keywordflow}{if} (firstChar == 0 && secondChar != 0)
457             \{
458                 returnValue = -1;
459                 
460                 \textcolor{keywordflow}{break};
461             \}
462             
463             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (firstChar != 0 && secondChar == 0)
464             \{
465                 returnValue = 1;
466                 
467                 \textcolor{keywordflow}{break};
468             \}
469             
470             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (firstChar == 0 && secondChar == 0)
471             \{
472                 returnValue = 0;
473                 
474                 \textcolor{keywordflow}{break};
475             \}
476             
477             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (firstChar < secondChar)
478             \{
479                 returnValue = -1;
480                 
481                 \textcolor{keywordflow}{break};
482             \}
483             
484             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (firstChar > secondChar)
485             \{
486                 returnValue = 1;
487                 
488                 \textcolor{keywordflow}{break};
489             \}
490             
491             theFirstCStr++;
492             theSecondCStr++;
493         \}
494     \}
495     
496     
497     \textcolor{keywordflow}{return}(returnValue);
498 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=305pt]{_c_p_string_utils_8hpp_a37f6b16c8163132d0cf8e6c41465f3d9_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Compare\+C\+Str\+To\+P\+Str@{Compare\+C\+Str\+To\+P\+Str}}
\index{Compare\+C\+Str\+To\+P\+Str@{Compare\+C\+Str\+To\+P\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Compare\+C\+Str\+To\+P\+Str(const char $\ast$the\+C\+Str, const unsigned char $\ast$the\+P\+Str, const Boolean ignore\+Case=true)}{CompareCStrToPStr(const char *theCStr, const unsigned char *thePStr, const Boolean ignoreCase=true)}}]{\setlength{\rightskip}{0pt plus 5cm}int Compare\+C\+Str\+To\+P\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+C\+Str, }
\item[{const unsigned char $\ast$}]{the\+P\+Str, }
\item[{const Boolean}]{ignore\+Case = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a2c03ff62793cc8c6e2f8dc64fc547278}{}\label{_c_p_string_utils_8hpp_a2c03ff62793cc8c6e2f8dc64fc547278}


Definition at line 604 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
605 \{
606 \textcolor{keywordtype}{int}     returnValue;
607 \textcolor{keywordtype}{char}    tempString[256];
608 
609     
610     returnValue = 0;
611     
612     \textcolor{keywordflow}{if} (theCStr != nil && thePStr != nil)
613     \{
614         \hyperlink{_c_p_string_utils_8cpp_aa3d21c3114a0a989f06c86d78d4d10c2}{CopyPStrToCStr}(thePStr,tempString,\textcolor{keyword}{sizeof}(tempString));
615         
616         returnValue = \hyperlink{_c_p_string_utils_8cpp_a8369205cf1bbcea9abb902cd285a5887}{CompareCStrs}(theCStr,tempString,ignoreCase);
617     \}
618     
619     
620     \textcolor{keywordflow}{return}(returnValue);
621 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=312pt]{_c_p_string_utils_8hpp_a2c03ff62793cc8c6e2f8dc64fc547278_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!C\+Strs\+Are\+Equal@{C\+Strs\+Are\+Equal}}
\index{C\+Strs\+Are\+Equal@{C\+Strs\+Are\+Equal}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{C\+Strs\+Are\+Equal(const char $\ast$the\+First\+C\+Str, const char $\ast$the\+Second\+C\+Str, const Boolean ignore\+Case=true)}{CStrsAreEqual(const char *theFirstCStr, const char *theSecondCStr, const Boolean ignoreCase=true)}}]{\setlength{\rightskip}{0pt plus 5cm}Boolean C\+Strs\+Are\+Equal (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+First\+C\+Str, }
\item[{const char $\ast$}]{the\+Second\+C\+Str, }
\item[{const Boolean}]{ignore\+Case = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_aaf40a097b6686f4f6a7f154b6bc4caa1}{}\label{_c_p_string_utils_8hpp_aaf40a097b6686f4f6a7f154b6bc4caa1}


Definition at line 502 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
503 \{
504     \textcolor{keywordflow}{if} (\hyperlink{_c_p_string_utils_8cpp_a8369205cf1bbcea9abb902cd285a5887}{CompareCStrs}(theFirstCStr,theSecondCStr,ignoreCase) == 0)
505     \{
506         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
507     \}
508     
509     \textcolor{keywordflow}{else}
510     \{
511         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
512     \}
513 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=280pt]{_c_p_string_utils_8hpp_aaf40a097b6686f4f6a7f154b6bc4caa1_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!P\+Strs\+Are\+Equal@{P\+Strs\+Are\+Equal}}
\index{P\+Strs\+Are\+Equal@{P\+Strs\+Are\+Equal}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{P\+Strs\+Are\+Equal(const unsigned char $\ast$the\+First\+C\+Str, const unsigned char $\ast$the\+Second\+C\+Str, const Boolean ignore\+Case=true)}{PStrsAreEqual(const unsigned char *theFirstCStr, const unsigned char *theSecondCStr, const Boolean ignoreCase=true)}}]{\setlength{\rightskip}{0pt plus 5cm}Boolean P\+Strs\+Are\+Equal (
\begin{DoxyParamCaption}
\item[{const unsigned char $\ast$}]{the\+First\+C\+Str, }
\item[{const unsigned char $\ast$}]{the\+Second\+C\+Str, }
\item[{const Boolean}]{ignore\+Case = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_aeb1e80b8fd78f6ee009f6e91bb117d79}{}\label{_c_p_string_utils_8hpp_aeb1e80b8fd78f6ee009f6e91bb117d79}


Definition at line 516 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
517 \{
518     \textcolor{keywordflow}{if} (\hyperlink{_c_p_string_utils_8cpp_a02390a479ba5e5cb58ed1e14c83c08ca}{ComparePStrs}(theFirstPStr,theSecondPStr,ignoreCase) == 0)
519     \{
520         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
521     \}
522     
523     \textcolor{keywordflow}{else}
524     \{
525         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
526     \}
527 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=279pt]{_c_p_string_utils_8hpp_aeb1e80b8fd78f6ee009f6e91bb117d79_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+Long\+Int\+To\+C\+Str@{Copy\+Long\+Int\+To\+C\+Str}}
\index{Copy\+Long\+Int\+To\+C\+Str@{Copy\+Long\+Int\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+Long\+Int\+To\+C\+Str(const long the\+Num, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length, const int num\+Digits=-\/1)}{CopyLongIntToCStr(const long theNum, char *theCStr, const int maxCStrLength, const int numDigits=-1)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+Long\+Int\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const long}]{the\+Num, }
\item[{char $\ast$}]{the\+C\+Str, }
\item[{const int}]{max\+C\+Str\+Length, }
\item[{const int}]{num\+Digits = {\ttfamily -\/1}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ae3951b84f4eaf77fd9b9abbd5b95b776}{}\label{_c_p_string_utils_8hpp_ae3951b84f4eaf77fd9b9abbd5b95b776}


Definition at line 711 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
712 \{
713 Str255      theStr255;
714 
715 
716     NumToString(theNum,theStr255);
717 
718 
719     \textcolor{keywordflow}{if} (numDigits > 0)
720     \{
721     \textcolor{keywordtype}{int}     charsToInsert;
722     
723         
724         charsToInsert = numDigits - \hyperlink{_c_p_string_utils_8cpp_a8777f51d38bd32a8bc1b422f0dfbaf26}{PStrLength}(theStr255);
725         
726         \textcolor{keywordflow}{if} (charsToInsert > 0)
727         \{
728         \textcolor{keywordtype}{char}    tempString[256];
729             
730             \hyperlink{_c_p_string_utils_8cpp_a658e88bafe1cb451f10d3f01a7264359}{CopyCStrToCStr}(\textcolor{stringliteral}{""},tempString,\textcolor{keyword}{sizeof}(tempString));
731             
732             \textcolor{keywordflow}{for} (;charsToInsert > 0;charsToInsert--)
733             \{
734                 \hyperlink{_c_p_string_utils_8cpp_a5a59076beb65283c27a32e2a441b83a5}{ConcatCStrToCStr}(\textcolor{stringliteral}{"0"},tempString,\textcolor{keyword}{sizeof}(tempString));
735             \}
736             
737             \hyperlink{_c_p_string_utils_8cpp_a44cd98d7de0fb90ebc4680ea29394a59}{ConcatPStrToCStr}(theStr255,tempString,\textcolor{keyword}{sizeof}(tempString));
738             
739             \hyperlink{_c_p_string_utils_8cpp_a7f0f18d1bcacabcb386d67a202a62306}{CopyCStrToPStr}(tempString,theStr255,\textcolor{keyword}{sizeof}(theStr255));
740         \}
741     \}
742 
743 
744     \hyperlink{_c_p_string_utils_8cpp_aa3d21c3114a0a989f06c86d78d4d10c2}{CopyPStrToCStr}(theStr255,theCStr,maxCStrLength);
745 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=318pt]{_c_p_string_utils_8hpp_ae3951b84f4eaf77fd9b9abbd5b95b776_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_ae3951b84f4eaf77fd9b9abbd5b95b776_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+Unsigned\+Long\+Int\+To\+C\+Str@{Copy\+Unsigned\+Long\+Int\+To\+C\+Str}}
\index{Copy\+Unsigned\+Long\+Int\+To\+C\+Str@{Copy\+Unsigned\+Long\+Int\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+Unsigned\+Long\+Int\+To\+C\+Str(const unsigned long the\+Num, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length)}{CopyUnsignedLongIntToCStr(const unsigned long theNum, char *theCStr, const int maxCStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+Unsigned\+Long\+Int\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const unsigned long}]{the\+Num, }
\item[{char $\ast$}]{the\+C\+Str, }
\item[{const int}]{max\+C\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_aee5570d9c70a0d64e2aa60900dae7fa3}{}\label{_c_p_string_utils_8hpp_aee5570d9c70a0d64e2aa60900dae7fa3}


Definition at line 751 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
752 \{
753 \textcolor{keywordtype}{char}            tempString[256];
754 \textcolor{keywordtype}{int}             srcCharIndex,dstCharIndex;
755 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}   tempNum,quotient,remainder;
756 
757     
758     \textcolor{keywordflow}{if} (theNum == 0)
759     \{
760         \hyperlink{_c_p_string_utils_8cpp_a658e88bafe1cb451f10d3f01a7264359}{CopyCStrToCStr}(\textcolor{stringliteral}{"0"},theCStr,maxCStrLength);
761     \}
762     
763     \textcolor{keywordflow}{else}
764     \{
765         srcCharIndex = 0;
766         
767         tempNum = theNum;
768         
769         \textcolor{keywordflow}{for} (;;)
770         \{
771             \textcolor{keywordflow}{if} (srcCharIndex >= \textcolor{keyword}{sizeof}(tempString) - 1 || tempNum == 0)
772             \{
773                 \textcolor{keywordflow}{for} (dstCharIndex = 0;;)
774                 \{
775                     \textcolor{keywordflow}{if} (dstCharIndex >= maxCStrLength - 1 || srcCharIndex <= 0)
776                     \{
777                         theCStr[dstCharIndex] = 0;
778                         
779                         \textcolor{keywordflow}{break};
780                     \}
781                     
782                     theCStr[dstCharIndex++] = tempString[--srcCharIndex];
783                 \}
784                 
785                 \textcolor{keywordflow}{break};
786             \}
787             
788 
789             quotient = tempNum / 10;
790             
791             remainder = tempNum - (quotient * 10);
792             
793             tempString[srcCharIndex] = \textcolor{charliteral}{'0'} + remainder;
794             
795             srcCharIndex++;
796             
797             tempNum = quotient;
798         \}
799     \}
800 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_aee5570d9c70a0d64e2aa60900dae7fa3_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Concat\+Long\+Int\+To\+C\+Str@{Concat\+Long\+Int\+To\+C\+Str}}
\index{Concat\+Long\+Int\+To\+C\+Str@{Concat\+Long\+Int\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Concat\+Long\+Int\+To\+C\+Str(const long the\+Num, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length, const int num\+Digits=-\/1)}{ConcatLongIntToCStr(const long theNum, char *theCStr, const int maxCStrLength, const int numDigits=-1)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Concat\+Long\+Int\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const long}]{the\+Num, }
\item[{char $\ast$}]{the\+C\+Str, }
\item[{const int}]{max\+C\+Str\+Length, }
\item[{const int}]{num\+Digits = {\ttfamily -\/1}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a64e1d3d1c7820fa44990737ac7ad2092}{}\label{_c_p_string_utils_8hpp_a64e1d3d1c7820fa44990737ac7ad2092}


Definition at line 625 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
626 \{
627 Str255      theStr255;
628 
629 
630     NumToString(theNum,theStr255);
631 
632 
633     \textcolor{keywordflow}{if} (numDigits > 0)
634     \{
635     \textcolor{keywordtype}{int}     charsToInsert;
636     
637         
638         charsToInsert = numDigits - \hyperlink{_c_p_string_utils_8cpp_a8777f51d38bd32a8bc1b422f0dfbaf26}{PStrLength}(theStr255);
639         
640         \textcolor{keywordflow}{if} (charsToInsert > 0)
641         \{
642         \textcolor{keywordtype}{char}    tempString[256];
643             
644             \hyperlink{_c_p_string_utils_8cpp_a658e88bafe1cb451f10d3f01a7264359}{CopyCStrToCStr}(\textcolor{stringliteral}{""},tempString,\textcolor{keyword}{sizeof}(tempString));
645             
646             \textcolor{keywordflow}{for} (;charsToInsert > 0;charsToInsert--)
647             \{
648                 \hyperlink{_c_p_string_utils_8cpp_a5a59076beb65283c27a32e2a441b83a5}{ConcatCStrToCStr}(\textcolor{stringliteral}{"0"},tempString,\textcolor{keyword}{sizeof}(tempString));
649             \}
650             
651             \hyperlink{_c_p_string_utils_8cpp_a44cd98d7de0fb90ebc4680ea29394a59}{ConcatPStrToCStr}(theStr255,tempString,\textcolor{keyword}{sizeof}(tempString));
652             
653             \hyperlink{_c_p_string_utils_8cpp_a7f0f18d1bcacabcb386d67a202a62306}{CopyCStrToPStr}(tempString,theStr255,\textcolor{keyword}{sizeof}(theStr255));
654         \}
655     \}
656 
657 
658     \hyperlink{_c_p_string_utils_8cpp_a44cd98d7de0fb90ebc4680ea29394a59}{ConcatPStrToCStr}(theStr255,theCStr,maxCStrLength);
659 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=326pt]{_c_p_string_utils_8hpp_a64e1d3d1c7820fa44990737ac7ad2092_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a64e1d3d1c7820fa44990737ac7ad2092_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+And\+Concat\+Long\+Int\+To\+C\+Str@{Copy\+C\+Str\+And\+Concat\+Long\+Int\+To\+C\+Str}}
\index{Copy\+C\+Str\+And\+Concat\+Long\+Int\+To\+C\+Str@{Copy\+C\+Str\+And\+Concat\+Long\+Int\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+And\+Concat\+Long\+Int\+To\+C\+Str(const char $\ast$the\+Src\+C\+Str, const long the\+Num, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)}{CopyCStrAndConcatLongIntToCStr(const char *theSrcCStr, const long theNum, char *theDstCStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+C\+Str\+And\+Concat\+Long\+Int\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{const long}]{the\+Num, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a4e2365d621aafb89bbcfebd810b7df43}{}\label{_c_p_string_utils_8hpp_a4e2365d621aafb89bbcfebd810b7df43}


Definition at line 702 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
703 \{
704     \hyperlink{_c_p_string_utils_8cpp_a658e88bafe1cb451f10d3f01a7264359}{CopyCStrToCStr}(theSrcCStr,theDstCStr,maxDstStrLength);
705     
706     \hyperlink{_c_p_string_utils_8cpp_a58f67ce1b74a750bf1d9d22b87155b7e}{ConcatLongIntToCStr}(theNum,theDstCStr,maxDstStrLength);
707 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a4e2365d621aafb89bbcfebd810b7df43_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a4e2365d621aafb89bbcfebd810b7df43_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+Long\+Int\+To\+P\+Str@{Copy\+Long\+Int\+To\+P\+Str}}
\index{Copy\+Long\+Int\+To\+P\+Str@{Copy\+Long\+Int\+To\+P\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+Long\+Int\+To\+P\+Str(const long the\+Num, unsigned char $\ast$the\+P\+Str, const int max\+P\+Str\+Length, const int num\+Digits=-\/1)}{CopyLongIntToPStr(const long theNum, unsigned char *thePStr, const int maxPStrLength, const int numDigits=-1)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+Long\+Int\+To\+P\+Str (
\begin{DoxyParamCaption}
\item[{const long}]{the\+Num, }
\item[{unsigned char $\ast$}]{the\+P\+Str, }
\item[{const int}]{max\+P\+Str\+Length, }
\item[{const int}]{num\+Digits = {\ttfamily -\/1}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ae7ec7fd0450bef6db8a04fdeb7188005}{}\label{_c_p_string_utils_8hpp_ae7ec7fd0450bef6db8a04fdeb7188005}


Definition at line 805 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
806 \{
807 \textcolor{keywordtype}{char}    tempString[256];
808 
809 
810     \hyperlink{_c_p_string_utils_8cpp_a1dc2d9cb7f617c303647c336273c76a0}{CopyLongIntToCStr}(theNum,tempString,\textcolor{keyword}{sizeof}(tempString),numDigits);
811     
812     \hyperlink{_c_p_string_utils_8cpp_a7f0f18d1bcacabcb386d67a202a62306}{CopyCStrToPStr}(tempString,thePStr,maxPStrLength);
813 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_ae7ec7fd0450bef6db8a04fdeb7188005_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Concat\+Long\+Int\+To\+P\+Str@{Concat\+Long\+Int\+To\+P\+Str}}
\index{Concat\+Long\+Int\+To\+P\+Str@{Concat\+Long\+Int\+To\+P\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Concat\+Long\+Int\+To\+P\+Str(const long the\+Num, unsigned char $\ast$the\+P\+Str, const int max\+P\+Str\+Length, const int num\+Digits=-\/1)}{ConcatLongIntToPStr(const long theNum, unsigned char *thePStr, const int maxPStrLength, const int numDigits=-1)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Concat\+Long\+Int\+To\+P\+Str (
\begin{DoxyParamCaption}
\item[{const long}]{the\+Num, }
\item[{unsigned char $\ast$}]{the\+P\+Str, }
\item[{const int}]{max\+P\+Str\+Length, }
\item[{const int}]{num\+Digits = {\ttfamily -\/1}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a3f1c3ca8cd26c7c6b6214c6271ee4028}{}\label{_c_p_string_utils_8hpp_a3f1c3ca8cd26c7c6b6214c6271ee4028}


Definition at line 664 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
665 \{
666 Str255      theStr255;
667 
668 
669     NumToString(theNum,theStr255);
670 
671 
672     \textcolor{keywordflow}{if} (numDigits > 0)
673     \{
674     \textcolor{keywordtype}{int}     charsToInsert;
675     
676         
677         charsToInsert = numDigits - \hyperlink{_c_p_string_utils_8cpp_a8777f51d38bd32a8bc1b422f0dfbaf26}{PStrLength}(theStr255);
678         
679         \textcolor{keywordflow}{if} (charsToInsert > 0)
680         \{
681         \textcolor{keywordtype}{char}    tempString[256];
682             
683             \hyperlink{_c_p_string_utils_8cpp_a658e88bafe1cb451f10d3f01a7264359}{CopyCStrToCStr}(\textcolor{stringliteral}{""},tempString,\textcolor{keyword}{sizeof}(tempString));
684             
685             \textcolor{keywordflow}{for} (;charsToInsert > 0;charsToInsert--)
686             \{
687                 \hyperlink{_c_p_string_utils_8cpp_a5a59076beb65283c27a32e2a441b83a5}{ConcatCStrToCStr}(\textcolor{stringliteral}{"0"},tempString,\textcolor{keyword}{sizeof}(tempString));
688             \}
689             
690             \hyperlink{_c_p_string_utils_8cpp_a44cd98d7de0fb90ebc4680ea29394a59}{ConcatPStrToCStr}(theStr255,tempString,\textcolor{keyword}{sizeof}(tempString));
691             
692             \hyperlink{_c_p_string_utils_8cpp_a7f0f18d1bcacabcb386d67a202a62306}{CopyCStrToPStr}(tempString,theStr255,\textcolor{keyword}{sizeof}(theStr255));
693         \}
694     \}
695 
696 
697     \hyperlink{_c_p_string_utils_8cpp_a198a30aee033bf3193b22c4997733e2f}{ConcatPStrToPStr}(theStr255,thePStr,maxPStrLength);
698 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=325pt]{_c_p_string_utils_8hpp_a3f1c3ca8cd26c7c6b6214c6271ee4028_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!C\+Str\+Length@{C\+Str\+Length}}
\index{C\+Str\+Length@{C\+Str\+Length}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{C\+Str\+Length(const char $\ast$the\+C\+String)}{CStrLength(const char *theCString)}}]{\setlength{\rightskip}{0pt plus 5cm}long C\+Str\+Length (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+C\+String}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a7bfc8229791c1db249bbe38fbbc4cabf}{}\label{_c_p_string_utils_8hpp_a7bfc8229791c1db249bbe38fbbc4cabf}


Definition at line 1175 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1176 \{
1177 \textcolor{keywordtype}{long}    cStrLength = 0;
1178 
1179     
1180     \textcolor{keywordflow}{if} (theCString != nil)
1181     \{
1182         \textcolor{keywordflow}{for} (cStrLength = 0;theCString[cStrLength] != 0;cStrLength++)
1183         \{
1184         
1185         \}
1186     \}
1187     
1188     
1189     \textcolor{keywordflow}{return}(cStrLength);
1190 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a7bfc8229791c1db249bbe38fbbc4cabf_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!P\+Str\+Length@{P\+Str\+Length}}
\index{P\+Str\+Length@{P\+Str\+Length}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{P\+Str\+Length(const unsigned char $\ast$the\+P\+String)}{PStrLength(const unsigned char *thePString)}}]{\setlength{\rightskip}{0pt plus 5cm}long P\+Str\+Length (
\begin{DoxyParamCaption}
\item[{const unsigned char $\ast$}]{the\+P\+String}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a8777f51d38bd32a8bc1b422f0dfbaf26}{}\label{_c_p_string_utils_8hpp_a8777f51d38bd32a8bc1b422f0dfbaf26}


Definition at line 1194 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1195 \{
1196 \textcolor{keywordtype}{long}    pStrLength = 0;
1197 
1198     
1199     \textcolor{keywordflow}{if} (thePString != nil)
1200     \{
1201         pStrLength = thePString[0];
1202     \}
1203     
1204     
1205     \textcolor{keywordflow}{return}(pStrLength);
1206 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a8777f51d38bd32a8bc1b422f0dfbaf26_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+To\+Existing\+Handle@{Copy\+C\+Str\+To\+Existing\+Handle}}
\index{Copy\+C\+Str\+To\+Existing\+Handle@{Copy\+C\+Str\+To\+Existing\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+To\+Existing\+Handle(const char $\ast$the\+C\+String, Handle the\+Handle)}{CopyCStrToExistingHandle(const char *theCString, Handle theHandle)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Copy\+C\+Str\+To\+Existing\+Handle (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+C\+String, }
\item[{Handle}]{the\+Handle}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a17298ac0cbc833e92e060af6205759e3}{}\label{_c_p_string_utils_8hpp_a17298ac0cbc833e92e060af6205759e3}


Definition at line 847 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
848 \{
849 OSErr   errCode = noErr;
850 \textcolor{keywordtype}{long}    stringLength;
851 
852     
853     \textcolor{keywordflow}{if} (theCString == nil)
854     \{
855         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyCStrToExistingHandle: Bad parameter, theCString
       == nil"}));
856     \}
857 
858     \textcolor{keywordflow}{if} (theHandle == nil)
859     \{
860         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyCStrToExistingHandle: Bad parameter, theHandle
       == nil"}));
861     \}
862 
863     \textcolor{keywordflow}{if} (*theHandle == nil)
864     \{
865         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyCStrToExistingHandle: Bad parameter, *theHandle
       == nil"}));
866     \}
867 
868 
869 
870     stringLength = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theCString) + 1;
871     
872     SetHandleSize(theHandle,stringLength);
873     
874     \textcolor{keywordflow}{if} (GetHandleSize(theHandle) < stringLength)
875     \{
876         \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"CopyCStrToExistingHandle: Can't
       set Handle size, MemError() = "},MemError());
877     \}
878     
879     
880     ::BlockMove(theCString,*theHandle,stringLength);
881     
882 
883 EXITPOINT:
884     
885     \textcolor{keywordflow}{return}(errCode);
886 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=319pt]{_c_p_string_utils_8hpp_a17298ac0cbc833e92e060af6205759e3_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a17298ac0cbc833e92e060af6205759e3_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+Long\+Int\+To\+Existing\+Handle@{Copy\+Long\+Int\+To\+Existing\+Handle}}
\index{Copy\+Long\+Int\+To\+Existing\+Handle@{Copy\+Long\+Int\+To\+Existing\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+Long\+Int\+To\+Existing\+Handle(const long in\+The\+Long\+Int, Handle the\+Handle)}{CopyLongIntToExistingHandle(const long inTheLongInt, Handle theHandle)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Copy\+Long\+Int\+To\+Existing\+Handle (
\begin{DoxyParamCaption}
\item[{const long}]{in\+The\+Long\+Int, }
\item[{Handle}]{the\+Handle}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a36a4cfe0d92feb38df9b222a0cd56d7d}{}\label{_c_p_string_utils_8hpp_a36a4cfe0d92feb38df9b222a0cd56d7d}


Definition at line 831 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
832 \{
833 OSErr       errCode = noErr;
834 \textcolor{keywordtype}{char}        tempString[32];
835     
836     
837     \hyperlink{_c_p_string_utils_8cpp_a1dc2d9cb7f617c303647c336273c76a0}{CopyLongIntToCStr}(inTheLongInt,tempString,\textcolor{keyword}{sizeof}(tempString));
838     
839     errCode = \hyperlink{_c_p_string_utils_8cpp_a17298ac0cbc833e92e060af6205759e3}{CopyCStrToExistingHandle}(tempString,theHandle);
840 
841     \textcolor{keywordflow}{return}(errCode);
842 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a36a4cfe0d92feb38df9b222a0cd56d7d_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+To\+New\+Handle@{Copy\+C\+Str\+To\+New\+Handle}}
\index{Copy\+C\+Str\+To\+New\+Handle@{Copy\+C\+Str\+To\+New\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+To\+New\+Handle(const char $\ast$the\+C\+String, Handle $\ast$the\+Handle)}{CopyCStrToNewHandle(const char *theCString, Handle *theHandle)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Copy\+C\+Str\+To\+New\+Handle (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+C\+String, }
\item[{Handle $\ast$}]{the\+Handle}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_aca7ebd368152c239cb4ca3876708ae83}{}\label{_c_p_string_utils_8hpp_aca7ebd368152c239cb4ca3876708ae83}


Definition at line 892 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
893 \{
894 OSErr   errCode = noErr;
895 \textcolor{keywordtype}{long}    stringLength;
896 
897     
898     \textcolor{keywordflow}{if} (theCString == nil)
899     \{
900         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyCStrToNewHandle: Bad parameter, theCString ==
       nil"}));
901     \}
902 
903     \textcolor{keywordflow}{if} (theHandle == nil)
904     \{
905         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyCStrToNewHandle: Bad parameter, theHandle == nil
      "}));
906     \}
907 
908 
909 
910     stringLength = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theCString) + 1;
911     
912     *theHandle = NewHandle(stringLength);
913     
914     \textcolor{keywordflow}{if} (*theHandle == nil)
915     \{
916         \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"CopyCStrToNewHandle: Can't
       allocate Handle, MemError() = "},MemError());
917     \}
918     
919     
920     ::BlockMove(theCString,**theHandle,stringLength);
921     
922 
923 EXITPOINT:
924     
925     \textcolor{keywordflow}{return}(errCode);
926 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=304pt]{_c_p_string_utils_8hpp_aca7ebd368152c239cb4ca3876708ae83_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_aca7ebd368152c239cb4ca3876708ae83_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+P\+Str\+To\+New\+Handle@{Copy\+P\+Str\+To\+New\+Handle}}
\index{Copy\+P\+Str\+To\+New\+Handle@{Copy\+P\+Str\+To\+New\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+P\+Str\+To\+New\+Handle(const unsigned char $\ast$the\+P\+String, Handle $\ast$the\+Handle)}{CopyPStrToNewHandle(const unsigned char *thePString, Handle *theHandle)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Copy\+P\+Str\+To\+New\+Handle (
\begin{DoxyParamCaption}
\item[{const unsigned char $\ast$}]{the\+P\+String, }
\item[{Handle $\ast$}]{the\+Handle}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a880111ae616a1551b6294802dbbef1fa}{}\label{_c_p_string_utils_8hpp_a880111ae616a1551b6294802dbbef1fa}


Definition at line 930 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
931 \{
932 OSErr   errCode = noErr;
933 \textcolor{keywordtype}{long}    stringLength;
934 
935     
936     \textcolor{keywordflow}{if} (thePString == nil)
937     \{
938         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyPStrToNewHandle: Bad parameter, thePString ==
       nil"}));
939     \}
940 
941     \textcolor{keywordflow}{if} (theHandle == nil)
942     \{
943         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyPStrToNewHandle: Bad parameter, theHandle == nil
      "}));
944     \}
945 
946 
947 
948     stringLength = \hyperlink{_c_p_string_utils_8cpp_a8777f51d38bd32a8bc1b422f0dfbaf26}{PStrLength}(thePString) + 1;
949     
950     *theHandle = NewHandle(stringLength);
951     
952     \textcolor{keywordflow}{if} (*theHandle == nil)
953     \{
954         \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"CopyPStrToNewHandle: Can't
       allocate Handle, MemError() = "},MemError());
955     \}
956     
957     
958     \textcolor{keywordflow}{if} (stringLength > 1)
959     \{
960         BlockMove(thePString + 1,**theHandle,stringLength - 1);
961     \}
962     
963     (**theHandle)[stringLength - 1] = 0;
964     
965 
966 EXITPOINT:
967     
968     \textcolor{keywordflow}{return}(errCode);
969 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=303pt]{_c_p_string_utils_8hpp_a880111ae616a1551b6294802dbbef1fa_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+Long\+Int\+To\+New\+Handle@{Copy\+Long\+Int\+To\+New\+Handle}}
\index{Copy\+Long\+Int\+To\+New\+Handle@{Copy\+Long\+Int\+To\+New\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+Long\+Int\+To\+New\+Handle(const long in\+The\+Long\+Int, Handle $\ast$the\+Handle)}{CopyLongIntToNewHandle(const long inTheLongInt, Handle *theHandle)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Copy\+Long\+Int\+To\+New\+Handle (
\begin{DoxyParamCaption}
\item[{const long}]{in\+The\+Long\+Int, }
\item[{Handle $\ast$}]{the\+Handle}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a4c4ba0a343f429d4fd4a1b7857f67de8}{}\label{_c_p_string_utils_8hpp_a4c4ba0a343f429d4fd4a1b7857f67de8}


Definition at line 817 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
818 \{
819 OSErr       errCode = noErr;
820 \textcolor{keywordtype}{char}        tempString[32];
821     
822     
823     \hyperlink{_c_p_string_utils_8cpp_a1dc2d9cb7f617c303647c336273c76a0}{CopyLongIntToCStr}(inTheLongInt,tempString,\textcolor{keyword}{sizeof}(tempString));
824     
825     errCode = \hyperlink{_c_p_string_utils_8cpp_aca7ebd368152c239cb4ca3876708ae83}{CopyCStrToNewHandle}(tempString,theHandle);
826 
827     \textcolor{keywordflow}{return}(errCode);
828 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a4c4ba0a343f429d4fd4a1b7857f67de8_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Append\+C\+Str\+To\+Handle@{Append\+C\+Str\+To\+Handle}}
\index{Append\+C\+Str\+To\+Handle@{Append\+C\+Str\+To\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Append\+C\+Str\+To\+Handle(const char $\ast$the\+C\+String, Handle the\+Handle, long $\ast$current\+Length=nil, long $\ast$max\+Length=nil)}{AppendCStrToHandle(const char *theCString, Handle theHandle, long *currentLength=nil, long *maxLength=nil)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Append\+C\+Str\+To\+Handle (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+C\+String, }
\item[{Handle}]{the\+Handle, }
\item[{long $\ast$}]{current\+Length = {\ttfamily nil}, }
\item[{long $\ast$}]{max\+Length = {\ttfamily nil}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a9b32e839b7ae85cfec09a99ccfd0383c}{}\label{_c_p_string_utils_8hpp_a9b32e839b7ae85cfec09a99ccfd0383c}


Definition at line 990 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
991 \{
992 OSErr       errCode = noErr;
993 \textcolor{keywordtype}{long}        handleMaxLength,handleCurrentLength,stringLength,byteCount;
994 
995 
996     \textcolor{keywordflow}{if} (theCString == nil)
997     \{
998         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"AppendCStrToHandle: Bad parameter, theCString == nil
      "}));
999     \}
1000 
1001     \textcolor{keywordflow}{if} (theHandle == nil)
1002     \{
1003         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"AppendCStrToHandle: Bad parameter, theHandle == nil"}
      ));
1004     \}
1005     
1006     
1007     \textcolor{keywordflow}{if} (maxLength != nil)
1008     \{
1009         handleMaxLength = *maxLength;
1010     \}
1011     
1012     \textcolor{keywordflow}{else}
1013     \{
1014         handleMaxLength = GetHandleSize(theHandle);
1015     \}
1016     
1017     
1018     \textcolor{keywordflow}{if} (currentLength != nil && *currentLength >= 0)
1019     \{
1020         handleCurrentLength = *currentLength;
1021     \}
1022     
1023     \textcolor{keywordflow}{else}
1024     \{
1025         handleCurrentLength = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(*theHandle);
1026     \}
1027     
1028     
1029     stringLength = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theCString);
1030     
1031     byteCount = handleCurrentLength + stringLength + 1;
1032     
1033     \textcolor{keywordflow}{if} (byteCount > handleMaxLength)
1034     \{
1035         SetHandleSize(theHandle,handleCurrentLength + stringLength + 1);
1036         
1037         \textcolor{keywordflow}{if} (maxLength != nil)
1038         \{
1039             *maxLength = GetHandleSize(theHandle);
1040             
1041             handleMaxLength = *maxLength;
1042         \}
1043         
1044         \textcolor{keywordflow}{else}
1045         \{
1046             handleMaxLength = GetHandleSize(theHandle);
1047         \}
1048 
1049         \textcolor{keywordflow}{if} (byteCount > handleMaxLength)
1050         \{
1051             \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"AppendCStrToHandle: Can't
       increase Handle allocation, MemError() = "},MemError());
1052         \}
1053     \}
1054     
1055     
1056     BlockMove(theCString,*theHandle + handleCurrentLength,stringLength + 1);
1057     
1058     
1059     \textcolor{keywordflow}{if} (currentLength != nil)
1060     \{
1061         *currentLength += stringLength;
1062     \}
1063 
1064 
1065     errCode = noErr;
1066     
1067     
1068 EXITPOINT:
1069 
1070     \textcolor{keywordflow}{return}(errCode);
1071 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=295pt]{_c_p_string_utils_8hpp_a9b32e839b7ae85cfec09a99ccfd0383c_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a9b32e839b7ae85cfec09a99ccfd0383c_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Append\+Chars\+To\+Handle@{Append\+Chars\+To\+Handle}}
\index{Append\+Chars\+To\+Handle@{Append\+Chars\+To\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Append\+Chars\+To\+Handle(const char $\ast$the\+Chars, const int num\+Chars, Handle the\+Handle, long $\ast$current\+Length=nil, long $\ast$max\+Length=nil)}{AppendCharsToHandle(const char *theChars, const int numChars, Handle theHandle, long *currentLength=nil, long *maxLength=nil)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Append\+Chars\+To\+Handle (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Chars, }
\item[{const int}]{num\+Chars, }
\item[{Handle}]{the\+Handle, }
\item[{long $\ast$}]{current\+Length = {\ttfamily nil}, }
\item[{long $\ast$}]{max\+Length = {\ttfamily nil}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a7784942e61324e5d726870b3a648c40c}{}\label{_c_p_string_utils_8hpp_a7784942e61324e5d726870b3a648c40c}


Definition at line 1075 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1076 \{
1077 OSErr       errCode = noErr;
1078 \textcolor{keywordtype}{long}        handleMaxLength,handleCurrentLength,byteCount;
1079 
1080 
1081     \textcolor{keywordflow}{if} (theChars == nil)
1082     \{
1083         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"AppendCharsToHandle: Bad parameter, theChars == nil"}
      ));
1084     \}
1085 
1086     \textcolor{keywordflow}{if} (theHandle == nil)
1087     \{
1088         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"AppendCharsToHandle: Bad parameter, theHandle == nil
      "}));
1089     \}
1090     
1091     
1092     \textcolor{keywordflow}{if} (maxLength != nil)
1093     \{
1094         handleMaxLength = *maxLength;
1095     \}
1096     
1097     \textcolor{keywordflow}{else}
1098     \{
1099         handleMaxLength = GetHandleSize(theHandle);
1100     \}
1101     
1102     
1103     \textcolor{keywordflow}{if} (currentLength != nil && *currentLength >= 0)
1104     \{
1105         handleCurrentLength = *currentLength;
1106     \}
1107     
1108     \textcolor{keywordflow}{else}
1109     \{
1110         handleCurrentLength = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(*theHandle);
1111     \}
1112     
1113     
1114     byteCount = handleCurrentLength + numChars + 1;
1115     
1116     \textcolor{keywordflow}{if} (byteCount > handleMaxLength)
1117     \{
1118         SetHandleSize(theHandle,handleCurrentLength + numChars + 1);
1119         
1120         \textcolor{keywordflow}{if} (maxLength != nil)
1121         \{
1122             *maxLength = GetHandleSize(theHandle);
1123             
1124             handleMaxLength = *maxLength;
1125         \}
1126         
1127         \textcolor{keywordflow}{else}
1128         \{
1129             handleMaxLength = GetHandleSize(theHandle);
1130         \}
1131 
1132         \textcolor{keywordflow}{if} (byteCount > handleMaxLength)
1133         \{
1134             \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"AppendCharsToHandle: Can't
       increase Handle allocation, MemError() = "},MemError());
1135         \}
1136     \}
1137     
1138     
1139     BlockMove(theChars,*theHandle + handleCurrentLength,numChars);
1140     
1141     (*theHandle)[handleCurrentLength + numChars] = \textcolor{charliteral}{'\(\backslash\)0'};
1142     
1143     \textcolor{keywordflow}{if} (currentLength != nil)
1144     \{
1145         *currentLength += numChars;
1146     \}
1147 
1148 
1149     errCode = noErr;
1150     
1151     
1152 EXITPOINT:
1153 
1154     \textcolor{keywordflow}{return}(errCode);
1155 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=302pt]{_c_p_string_utils_8hpp_a7784942e61324e5d726870b3a648c40c_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Append\+P\+Str\+To\+Handle@{Append\+P\+Str\+To\+Handle}}
\index{Append\+P\+Str\+To\+Handle@{Append\+P\+Str\+To\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Append\+P\+Str\+To\+Handle(const unsigned char $\ast$the\+P\+String, Handle the\+Handle, long $\ast$current\+Length=nil)}{AppendPStrToHandle(const unsigned char *thePString, Handle theHandle, long *currentLength=nil)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Append\+P\+Str\+To\+Handle (
\begin{DoxyParamCaption}
\item[{const unsigned char $\ast$}]{the\+P\+String, }
\item[{Handle}]{the\+Handle, }
\item[{long $\ast$}]{current\+Length = {\ttfamily nil}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ada3a36e1dca388a31ef20508b4d71130}{}\label{_c_p_string_utils_8hpp_ada3a36e1dca388a31ef20508b4d71130}


Definition at line 972 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
973 \{
974 OSErr       errCode = noErr;
975 \textcolor{keywordtype}{char}        tempString[256];
976 
977     
978     \hyperlink{_c_p_string_utils_8cpp_aa3d21c3114a0a989f06c86d78d4d10c2}{CopyPStrToCStr}(thePString,tempString,\textcolor{keyword}{sizeof}(tempString));
979     
980     errCode = \hyperlink{_c_p_string_utils_8cpp_a96a5a07dbeb8f42dcadf494d15c2ca71}{AppendCStrToHandle}(tempString,theHandle,currentLength);
981     
982 
983 EXITPOINT:
984     
985     \textcolor{keywordflow}{return}(errCode);
986 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_ada3a36e1dca388a31ef20508b4d71130_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Append\+Long\+Int\+To\+Handle@{Append\+Long\+Int\+To\+Handle}}
\index{Append\+Long\+Int\+To\+Handle@{Append\+Long\+Int\+To\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Append\+Long\+Int\+To\+Handle(const long in\+The\+Long\+Int, Handle the\+Handle, long $\ast$current\+Length=nil)}{AppendLongIntToHandle(const long inTheLongInt, Handle theHandle, long *currentLength=nil)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Append\+Long\+Int\+To\+Handle (
\begin{DoxyParamCaption}
\item[{const long}]{in\+The\+Long\+Int, }
\item[{Handle}]{the\+Handle, }
\item[{long $\ast$}]{current\+Length = {\ttfamily nil}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_aa9b2aeca003a12bfdf8c4845bc6e94e6}{}\label{_c_p_string_utils_8hpp_aa9b2aeca003a12bfdf8c4845bc6e94e6}


Definition at line 1159 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1160 \{
1161 OSErr       errCode = noErr;
1162 \textcolor{keywordtype}{char}        tempString[32];
1163     
1164     
1165     \hyperlink{_c_p_string_utils_8cpp_a1dc2d9cb7f617c303647c336273c76a0}{CopyLongIntToCStr}(inTheLongInt,tempString,\textcolor{keyword}{sizeof}(tempString));
1166     
1167     errCode = \hyperlink{_c_p_string_utils_8cpp_a96a5a07dbeb8f42dcadf494d15c2ca71}{AppendCStrToHandle}(tempString,theHandle,currentLength);
1168 
1169     \textcolor{keywordflow}{return}(errCode);
1170 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_aa9b2aeca003a12bfdf8c4845bc6e94e6_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Zero\+Mem@{Zero\+Mem}}
\index{Zero\+Mem@{Zero\+Mem}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Zero\+Mem(void $\ast$the\+Mem\+Ptr, const unsigned long num\+Bytes)}{ZeroMem(void *theMemPtr, const unsigned long numBytes)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Zero\+Mem (
\begin{DoxyParamCaption}
\item[{{\bf void} $\ast$}]{the\+Mem\+Ptr, }
\item[{const unsigned long}]{num\+Bytes}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a7b94ca1621d33746b4148de1a3fa7e09}{}\label{_c_p_string_utils_8hpp_a7b94ca1621d33746b4148de1a3fa7e09}


Definition at line 1212 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1213 \{
1214 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}   *theBytePtr;
1215 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}   *theLongPtr;
1216 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}   numSingleBytes;
1217 \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long}   theNumBytes;
1218 
1219     
1220     theNumBytes = numBytes;
1221     
1222     \textcolor{keywordflow}{if} (theMemPtr != nil && theNumBytes > 0)
1223     \{
1224         theBytePtr = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) theMemPtr;
1225         
1226         numSingleBytes = (\textcolor{keywordtype}{unsigned} long) theBytePtr & 0x0003;
1227         
1228         \textcolor{keywordflow}{while} (numSingleBytes > 0)
1229         \{
1230             *theBytePtr++ = 0;
1231             
1232             theNumBytes--;
1233             numSingleBytes--;
1234         \}
1235         
1236 
1237         theLongPtr = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} *) theBytePtr;
1238         
1239         \textcolor{keywordflow}{while} (theNumBytes >= 4)
1240         \{
1241             *theLongPtr++ = 0;
1242             
1243             theNumBytes -= 4;
1244         \}
1245         
1246         
1247         theBytePtr = (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *) theLongPtr;
1248         
1249         \textcolor{keywordflow}{while} (theNumBytes > 0)
1250         \{
1251             *theBytePtr++ = 0;
1252             
1253             theNumBytes--;
1254         \}
1255     \}
1256 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Find\+Char\+In\+C\+Str@{Find\+Char\+In\+C\+Str}}
\index{Find\+Char\+In\+C\+Str@{Find\+Char\+In\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Find\+Char\+In\+C\+Str(const char the\+Char, const char $\ast$the\+C\+String)}{FindCharInCStr(const char theChar, const char *theCString)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ Find\+Char\+In\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char}]{the\+Char, }
\item[{const char $\ast$}]{the\+C\+String}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ab2ff3b5fef54bdc960894a5c69085f63}{}\label{_c_p_string_utils_8hpp_ab2ff3b5fef54bdc960894a5c69085f63}


Definition at line 1261 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1262 \{
1263 \textcolor{keywordtype}{char}    *theStringSearchPtr;
1264 
1265     
1266     theStringSearchPtr = (\textcolor{keywordtype}{char}  *) theCString;
1267     
1268     \textcolor{keywordflow}{if} (theStringSearchPtr != nil)
1269     \{
1270         \textcolor{keywordflow}{while} (*theStringSearchPtr != \textcolor{charliteral}{'\(\backslash\)0'} && *theStringSearchPtr != theChar)
1271         \{
1272             theStringSearchPtr++;
1273         \}
1274         
1275         \textcolor{keywordflow}{if} (*theStringSearchPtr == \textcolor{charliteral}{'\(\backslash\)0'})
1276         \{
1277             theStringSearchPtr = nil;
1278         \}
1279     \}
1280     
1281     \textcolor{keywordflow}{return}(theStringSearchPtr);
1282 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Find\+Char\+Offset\+In\+C\+Str@{Find\+Char\+Offset\+In\+C\+Str}}
\index{Find\+Char\+Offset\+In\+C\+Str@{Find\+Char\+Offset\+In\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Find\+Char\+Offset\+In\+C\+Str(const char the\+Char, const char $\ast$the\+C\+String, const Boolean in\+Ignore\+Case=false)}{FindCharOffsetInCStr(const char theChar, const char *theCString, const Boolean inIgnoreCase=false)}}]{\setlength{\rightskip}{0pt plus 5cm}long Find\+Char\+Offset\+In\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char}]{the\+Char, }
\item[{const char $\ast$}]{the\+C\+String, }
\item[{const Boolean}]{in\+Ignore\+Case = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_acc01d7b45520285aef388331ed743a88}{}\label{_c_p_string_utils_8hpp_acc01d7b45520285aef388331ed743a88}


Definition at line 1286 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1287 \{
1288 \textcolor{keywordtype}{long}    theOffset = -1;
1289 
1290 
1291     \textcolor{keywordflow}{if} (theCString != nil)
1292     \{
1293         theOffset = 0;
1294         
1295 
1296         \textcolor{keywordflow}{if} (inIgnoreCase)
1297         \{
1298         \textcolor{keywordtype}{char}    searchChar = theChar;
1299         
1300             \textcolor{keywordflow}{if} (searchChar >= \textcolor{charliteral}{'a'} && searchChar <= \textcolor{charliteral}{'z'})
1301             \{
1302                 searchChar = searchChar - \textcolor{charliteral}{'a'} + \textcolor{charliteral}{'A'};
1303             \}
1304             
1305             
1306             \textcolor{keywordflow}{while} (*theCString != 0)
1307             \{
1308             \textcolor{keywordtype}{char}    currentChar = *theCString;
1309             
1310                 \textcolor{keywordflow}{if} (currentChar >= \textcolor{charliteral}{'a'} && currentChar <= \textcolor{charliteral}{'z'})
1311                 \{
1312                     currentChar = currentChar - \textcolor{charliteral}{'a'} + \textcolor{charliteral}{'A'};
1313                 \}
1314             
1315                 \textcolor{keywordflow}{if} (currentChar == searchChar)
1316                 \{
1317                     \textcolor{keywordflow}{break};
1318                 \}
1319                 
1320                 theCString++;
1321                 theOffset++;
1322             \}
1323         \}
1324         
1325         \textcolor{keywordflow}{else}
1326         \{
1327             \textcolor{keywordflow}{while} (*theCString != 0 && *theCString != theChar)
1328             \{
1329                 theCString++;
1330                 theOffset++;
1331             \}
1332         \}
1333         
1334         \textcolor{keywordflow}{if} (*theCString == 0)
1335         \{
1336             theOffset = -1;
1337         \}
1338     \}
1339     
1340     \textcolor{keywordflow}{return}(theOffset);
1341 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_acc01d7b45520285aef388331ed743a88_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Find\+C\+Str\+Offset\+In\+C\+Str@{Find\+C\+Str\+Offset\+In\+C\+Str}}
\index{Find\+C\+Str\+Offset\+In\+C\+Str@{Find\+C\+Str\+Offset\+In\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Find\+C\+Str\+Offset\+In\+C\+Str(const char $\ast$the\+C\+Substring, const char $\ast$the\+C\+String, const Boolean in\+Ignore\+Case=false)}{FindCStrOffsetInCStr(const char *theCSubstring, const char *theCString, const Boolean inIgnoreCase=false)}}]{\setlength{\rightskip}{0pt plus 5cm}long Find\+C\+Str\+Offset\+In\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+C\+Substring, }
\item[{const char $\ast$}]{the\+C\+String, }
\item[{const Boolean}]{in\+Ignore\+Case = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_aac76bdf05636cdba87b25dc2aac6f844}{}\label{_c_p_string_utils_8hpp_aac76bdf05636cdba87b25dc2aac6f844}


Definition at line 1344 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1345 \{
1346 \textcolor{keywordtype}{long}    theOffset = -1;
1347 
1348 
1349     \textcolor{keywordflow}{if} (theCSubstring != nil && theCString != nil)
1350     \{
1351         \textcolor{keywordflow}{for} (theOffset = 0;;theOffset++)
1352         \{
1353             \textcolor{keywordflow}{if} (theCString[theOffset] == 0)
1354             \{
1355                 theOffset = -1;
1356                 
1357                 \textcolor{keywordflow}{goto} EXITPOINT;
1358             \}
1359             
1360             
1361             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keywordtype}{char} *tempSubstringPtr = theCSubstring,*tempCStringPtr = theCString + theOffset;;
      tempSubstringPtr++,tempCStringPtr++)
1362             \{
1363                 \textcolor{keywordflow}{if} (*tempSubstringPtr == 0)
1364                 \{
1365                     \textcolor{keywordflow}{goto} EXITPOINT;
1366                 \}
1367                 
1368                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (*tempCStringPtr == 0)
1369                 \{
1370                     \textcolor{keywordflow}{break};
1371                 \}
1372             
1373             \textcolor{keywordtype}{char}    searchChar = *tempSubstringPtr;
1374             \textcolor{keywordtype}{char}    currentChar = *tempCStringPtr;
1375             
1376                 \textcolor{keywordflow}{if} (inIgnoreCase && searchChar >= \textcolor{charliteral}{'a'} && searchChar <= \textcolor{charliteral}{'z'})
1377                 \{
1378                     searchChar = searchChar - \textcolor{charliteral}{'a'} + \textcolor{charliteral}{'A'};
1379                 \}
1380                 
1381                 \textcolor{keywordflow}{if} (inIgnoreCase && currentChar >= \textcolor{charliteral}{'a'} && currentChar <= \textcolor{charliteral}{'z'})
1382                 \{
1383                     currentChar = currentChar - \textcolor{charliteral}{'a'} + \textcolor{charliteral}{'A'};
1384                 \}
1385                 
1386                 \textcolor{keywordflow}{if} (currentChar != searchChar)
1387                 \{
1388                     \textcolor{keywordflow}{break};
1389                 \}
1390             \}
1391         \}
1392         
1393         theOffset = -1;
1394     \}
1395 
1396 
1397 EXITPOINT:
1398     
1399     \textcolor{keywordflow}{return}(theOffset);
1400 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Substr\+To\+C\+Str@{Copy\+C\+Substr\+To\+C\+Str}}
\index{Copy\+C\+Substr\+To\+C\+Str@{Copy\+C\+Substr\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Substr\+To\+C\+Str(const char $\ast$the\+Src\+C\+Str, const int max\+Chars\+To\+Copy, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)}{CopyCSubstrToCStr(const char *theSrcCStr, const int maxCharsToCopy, char *theDstCStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+C\+Substr\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{const int}]{max\+Chars\+To\+Copy, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a807c6804e922fefe659d21f0ac10a751}{}\label{_c_p_string_utils_8hpp_a807c6804e922fefe659d21f0ac10a751}


Definition at line 153 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
154 \{
155 \textcolor{keywordtype}{int}     i;
156 
157 
158     \textcolor{keywordflow}{if} (theDstCStr != nil && theSrcCStr != nil && maxDstStrLength > 0)
159     \{
160         \textcolor{keywordflow}{for} (i = 0;;i++)
161         \{
162             \textcolor{keywordflow}{if} (theSrcCStr[i] == 0 || i >= maxDstStrLength - 1 || i >= maxCharsToCopy)
163             \{
164                 theDstCStr[i] = 0;
165                 
166                 \textcolor{keywordflow}{break};
167             \}
168             
169             \textcolor{keywordflow}{else}
170             \{
171                 theDstCStr[i] = theSrcCStr[i];
172             \}
173         \}
174     \}
175 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=346pt]{_c_p_string_utils_8hpp_a807c6804e922fefe659d21f0ac10a751_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Substr\+To\+P\+Str@{Copy\+C\+Substr\+To\+P\+Str}}
\index{Copy\+C\+Substr\+To\+P\+Str@{Copy\+C\+Substr\+To\+P\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Substr\+To\+P\+Str(const char $\ast$the\+Src\+C\+Str, const int max\+Chars\+To\+Copy, unsigned char $\ast$the\+Dst\+P\+Str, const int max\+Dst\+Str\+Length)}{CopyCSubstrToPStr(const char *theSrcCStr, const int maxCharsToCopy, unsigned char *theDstPStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+C\+Substr\+To\+P\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{const int}]{max\+Chars\+To\+Copy, }
\item[{unsigned char $\ast$}]{the\+Dst\+P\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a8e4ce194356b3d254d2bcfd5d3b607c9}{}\label{_c_p_string_utils_8hpp_a8e4ce194356b3d254d2bcfd5d3b607c9}


Definition at line 179 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
180 \{
181 \textcolor{keywordtype}{int}     i;
182 \textcolor{keywordtype}{int}     theMaxDstStrLength;
183 
184     
185     theMaxDstStrLength = maxDstStrLength;
186 
187     \textcolor{keywordflow}{if} (theDstPStr != nil && theSrcCStr != nil && theMaxDstStrLength > 0)
188     \{
189         \textcolor{keywordflow}{if} (theMaxDstStrLength > 255)
190         \{
191             theMaxDstStrLength = 255;
192         \}
193         
194         
195         \textcolor{keywordflow}{for} (i = 0;;i++)
196         \{
197             \textcolor{keywordflow}{if} (theSrcCStr[i] == 0 || i >= theMaxDstStrLength - 1 || i >= maxCharsToCopy)
198             \{
199                 theDstPStr[0] = i;
200                 
201                 \textcolor{keywordflow}{break};
202             \}
203             
204             \textcolor{keywordflow}{else}
205             \{
206                 theDstPStr[i + 1] = theSrcCStr[i];
207             \}
208         \}
209     \}
210 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Insert\+C\+Str\+Into\+C\+Str@{Insert\+C\+Str\+Into\+C\+Str}}
\index{Insert\+C\+Str\+Into\+C\+Str@{Insert\+C\+Str\+Into\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Insert\+C\+Str\+Into\+C\+Str(const char $\ast$the\+Src\+C\+Str, const int the\+Insertion\+Offset, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)}{InsertCStrIntoCStr(const char *theSrcCStr, const int theInsertionOffset, char *theDstCStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Insert\+C\+Str\+Into\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{const int}]{the\+Insertion\+Offset, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a8c50fd913403a328088f63b57578fe7b}{}\label{_c_p_string_utils_8hpp_a8c50fd913403a328088f63b57578fe7b}


Definition at line 1404 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1405 \{
1406 \textcolor{keywordtype}{int}     currentLength;
1407 \textcolor{keywordtype}{int}     insertLength;
1408 \textcolor{keywordtype}{int}     numCharsToInsert;
1409 \textcolor{keywordtype}{int}     numCharsToShift;
1410 
1411     
1412     \textcolor{keywordflow}{if} (theDstCStr != nil && theSrcCStr != nil && maxDstStrLength > 0 && theInsertionOffset < 
      maxDstStrLength - 1)
1413     \{
1414         currentLength = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theDstCStr);
1415         
1416         insertLength = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theSrcCStr);
1417         
1418 
1419         \textcolor{keywordflow}{if} (theInsertionOffset + insertLength < maxDstStrLength - 1)
1420         \{
1421             numCharsToInsert = insertLength;
1422         \}
1423         
1424         \textcolor{keywordflow}{else}
1425         \{
1426             numCharsToInsert = maxDstStrLength - 1 - theInsertionOffset;
1427         \}
1428         
1429 
1430         \textcolor{keywordflow}{if} (numCharsToInsert + currentLength < maxDstStrLength - 1)
1431         \{
1432             numCharsToShift = currentLength - theInsertionOffset;
1433         \}
1434         
1435         \textcolor{keywordflow}{else}
1436         \{
1437             numCharsToShift = maxDstStrLength - 1 - theInsertionOffset - numCharsToInsert;
1438         \}
1439 
1440         
1441         \textcolor{keywordflow}{if} (numCharsToShift > 0)
1442         \{
1443             BlockMove(theDstCStr + theInsertionOffset,theDstCStr + theInsertionOffset + numCharsToInsert,
      numCharsToShift);
1444         \}
1445         
1446         \textcolor{keywordflow}{if} (numCharsToInsert > 0)
1447         \{
1448             BlockMove(theSrcCStr,theDstCStr + theInsertionOffset,numCharsToInsert);
1449         \}
1450         
1451         theDstCStr[theInsertionOffset + numCharsToInsert + numCharsToShift] = 0;
1452     \}
1453 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=280pt]{_c_p_string_utils_8hpp_a8c50fd913403a328088f63b57578fe7b_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Insert\+P\+Str\+Into\+C\+Str@{Insert\+P\+Str\+Into\+C\+Str}}
\index{Insert\+P\+Str\+Into\+C\+Str@{Insert\+P\+Str\+Into\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Insert\+P\+Str\+Into\+C\+Str(const unsigned char $\ast$the\+Src\+P\+Str, const int the\+Insertion\+Offset, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)}{InsertPStrIntoCStr(const unsigned char *theSrcPStr, const int theInsertionOffset, char *theDstCStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Insert\+P\+Str\+Into\+C\+Str (
\begin{DoxyParamCaption}
\item[{const unsigned char $\ast$}]{the\+Src\+P\+Str, }
\item[{const int}]{the\+Insertion\+Offset, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ae91f36e64d41b4bf32c6d46d569f2feb}{}\label{_c_p_string_utils_8hpp_ae91f36e64d41b4bf32c6d46d569f2feb}


Definition at line 1457 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1458 \{
1459 \textcolor{keywordtype}{int}     currentLength;
1460 \textcolor{keywordtype}{int}     insertLength;
1461 \textcolor{keywordtype}{int}     numCharsToInsert;
1462 \textcolor{keywordtype}{int}     numCharsToShift;
1463 
1464     
1465     \textcolor{keywordflow}{if} (theDstCStr != nil && theSrcPStr != nil && maxDstStrLength > 0 && theInsertionOffset < 
      maxDstStrLength - 1)
1466     \{
1467         currentLength = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theDstCStr);
1468         
1469         insertLength = \hyperlink{_c_p_string_utils_8cpp_a8777f51d38bd32a8bc1b422f0dfbaf26}{PStrLength}(theSrcPStr);
1470         
1471 
1472         \textcolor{keywordflow}{if} (theInsertionOffset + insertLength < maxDstStrLength - 1)
1473         \{
1474             numCharsToInsert = insertLength;
1475         \}
1476         
1477         \textcolor{keywordflow}{else}
1478         \{
1479             numCharsToInsert = maxDstStrLength - 1 - theInsertionOffset;
1480         \}
1481         
1482 
1483         \textcolor{keywordflow}{if} (numCharsToInsert + currentLength < maxDstStrLength - 1)
1484         \{
1485             numCharsToShift = currentLength - theInsertionOffset;
1486         \}
1487         
1488         \textcolor{keywordflow}{else}
1489         \{
1490             numCharsToShift = maxDstStrLength - 1 - theInsertionOffset - numCharsToInsert;
1491         \}
1492 
1493         
1494         \textcolor{keywordflow}{if} (numCharsToShift > 0)
1495         \{
1496             BlockMove(theDstCStr + theInsertionOffset,theDstCStr + theInsertionOffset + numCharsToInsert,
      numCharsToShift);
1497         \}
1498         
1499         \textcolor{keywordflow}{if} (numCharsToInsert > 0)
1500         \{
1501             BlockMove(theSrcPStr + 1,theDstCStr + theInsertionOffset,numCharsToInsert);
1502         \}
1503         
1504         theDstCStr[theInsertionOffset + numCharsToInsert + numCharsToShift] = 0;
1505     \}
1506 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=280pt]{_c_p_string_utils_8hpp_ae91f36e64d41b4bf32c6d46d569f2feb_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Insert\+C\+Str\+Into\+Handle@{Insert\+C\+Str\+Into\+Handle}}
\index{Insert\+C\+Str\+Into\+Handle@{Insert\+C\+Str\+Into\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Insert\+C\+Str\+Into\+Handle(const char $\ast$the\+C\+String, Handle the\+Handle, const long in\+Insert\+Offset)}{InsertCStrIntoHandle(const char *theCString, Handle theHandle, const long inInsertOffset)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Insert\+C\+Str\+Into\+Handle (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+C\+String, }
\item[{Handle}]{the\+Handle, }
\item[{const long}]{in\+Insert\+Offset}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a71817681721c895409e8e09007172670}{}\label{_c_p_string_utils_8hpp_a71817681721c895409e8e09007172670}


Definition at line 1510 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1511 \{
1512 OSErr   errCode;
1513 \textcolor{keywordtype}{int}     currentLength;
1514 \textcolor{keywordtype}{int}     insertLength;
1515 
1516     
1517     \hyperlink{_error_handling_8hpp_a792b7061a295fc6f2a04dc813ebbf6dd}{SetErrorMessageAndBailIfNil}(theCString,\textcolor{stringliteral}{"InsertCStrIntoHandle: Bad parameter,
       theCString == nil"});
1518 
1519     \hyperlink{_error_handling_8hpp_a792b7061a295fc6f2a04dc813ebbf6dd}{SetErrorMessageAndBailIfNil}(theHandle,\textcolor{stringliteral}{"InsertCStrIntoHandle: Bad parameter,
       theHandle == nil"});
1520     
1521     currentLength = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(*theHandle);
1522     
1523     \textcolor{keywordflow}{if} (currentLength + 1 > ::GetHandleSize(theHandle))
1524     \{
1525         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}(\textcolor{stringliteral}{"InsertCStrIntoHandle: Handle has been overflowed"});
1526     \}
1527     
1528     \textcolor{keywordflow}{if} (inInsertOffset > currentLength)
1529     \{
1530         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}(\textcolor{stringliteral}{"InsertCStrIntoHandle: Insertion offset is greater
       than string length"});
1531     \}
1532     
1533     insertLength = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theCString);
1534     
1535     ::SetHandleSize(theHandle,currentLength + 1 + insertLength);
1536     
1537     \textcolor{keywordflow}{if} (::GetHandleSize(theHandle) < currentLength + 1 + insertLength)
1538     \{
1539         \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"InsertCStrIntoHandle: Can't
       expand storage for Handle, MemError() = "},MemError());
1540     \}
1541     
1542     ::BlockMove(*theHandle + inInsertOffset,*theHandle + inInsertOffset + insertLength,currentLength - 
      inInsertOffset + 1);
1543     
1544     ::BlockMove(theCString,*theHandle + inInsertOffset,insertLength);
1545 
1546 
1547     errCode = noErr;
1548     
1549     
1550 EXITPOINT:
1551 
1552     \textcolor{keywordflow}{return}(errCode);
1553 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=292pt]{_c_p_string_utils_8hpp_a71817681721c895409e8e09007172670_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+And\+Insert\+C\+Str\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert\+C\+Str\+Into\+C\+Str}}
\index{Copy\+C\+Str\+And\+Insert\+C\+Str\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert\+C\+Str\+Into\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+And\+Insert\+C\+Str\+Into\+C\+Str(const char $\ast$the\+Src\+C\+Str, const char $\ast$the\+Insert\+C\+Str, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)}{CopyCStrAndInsertCStrIntoCStr(const char *theSrcCStr, const char *theInsertCStr, char *theDstCStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+C\+Str\+And\+Insert\+C\+Str\+Into\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{const char $\ast$}]{the\+Insert\+C\+Str, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a96bc4869588910b804299c11aa72002c}{}\label{_c_p_string_utils_8hpp_a96bc4869588910b804299c11aa72002c}


Definition at line 1580 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1581 \{
1582 \textcolor{keyword}{const} \textcolor{keywordtype}{char}  *theCStrs[2] = \{ theInsertCStr,nil \};
1583 
1584     \hyperlink{_c_p_string_utils_8cpp_a8faf2025c36ae073f7eadea962f29e6c}{CopyCStrAndInsertCStrsLongIntsIntoCStr}(theSrcCStr,theCStrs,nil,
      theDstCStr,maxDstStrLength);
1585 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a96bc4869588910b804299c11aa72002c_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+And\+Insert\+C\+Strs\+Long\+Ints\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert\+C\+Strs\+Long\+Ints\+Into\+C\+Str}}
\index{Copy\+C\+Str\+And\+Insert\+C\+Strs\+Long\+Ints\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert\+C\+Strs\+Long\+Ints\+Into\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+And\+Insert\+C\+Strs\+Long\+Ints\+Into\+C\+Str(const char $\ast$the\+Src\+C\+Str, const char $\ast$$\ast$the\+Insert\+C\+Strs, const long $\ast$the\+Long\+Ints, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)}{CopyCStrAndInsertCStrsLongIntsIntoCStr(const char *theSrcCStr, const char **theInsertCStrs, const long *theLongInts, char *theDstCStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+C\+Str\+And\+Insert\+C\+Strs\+Long\+Ints\+Into\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{const char $\ast$$\ast$}]{the\+Insert\+C\+Strs, }
\item[{const long $\ast$}]{the\+Long\+Ints, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a8faf2025c36ae073f7eadea962f29e6c}{}\label{_c_p_string_utils_8hpp_a8faf2025c36ae073f7eadea962f29e6c}


Definition at line 1599 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1600 \{
1601 \textcolor{keywordtype}{int}         dstCharIndex,srcCharIndex,theMaxDstStrLength;
1602 \textcolor{keywordtype}{int}         theCStrIndex = 0;
1603 \textcolor{keywordtype}{int}         theLongIntIndex = 0;
1604 
1605     
1606     theMaxDstStrLength = maxDstStrLength;
1607     
1608     \textcolor{keywordflow}{if} (theDstCStr != nil && theSrcCStr != nil && theMaxDstStrLength > 0)
1609     \{
1610         dstCharIndex = 0;
1611         
1612         srcCharIndex = 0;
1613         
1614         
1615         \textcolor{comment}{//  Allow room for NULL at end of string}
1616         
1617         theMaxDstStrLength--;
1618         
1619         
1620         \textcolor{keywordflow}{for} (;;)
1621         \{
1622             \textcolor{comment}{//  Hit end of buffer?}
1623             
1624             \textcolor{keywordflow}{if} (dstCharIndex >= theMaxDstStrLength)
1625             \{
1626                 theDstCStr[dstCharIndex++] = 0;
1627                 
1628                 \textcolor{keywordflow}{goto} EXITPOINT;
1629             \}
1630             
1631             \textcolor{comment}{//  End of source string?}
1632             
1633             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (theSrcCStr[srcCharIndex] == 0)
1634             \{
1635                 theDstCStr[dstCharIndex++] = 0;
1636                 
1637                 \textcolor{keywordflow}{goto} EXITPOINT;
1638             \}
1639             
1640             \textcolor{comment}{//  Did we find a '%s'?}
1641             
1642             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (theInsertCStrs != nil && theInsertCStrs[theCStrIndex] != nil && theSrcCStr[
      srcCharIndex] == \textcolor{charliteral}{'%'} && theSrcCStr[srcCharIndex + 1] == \textcolor{charliteral}{'s'})
1643             \{
1644                 \textcolor{comment}{//  Skip over the '%s'}
1645                 
1646                 srcCharIndex += 2;
1647                 
1648                 
1649                 \textcolor{comment}{//  Terminate the dest string and then concat the string}
1650                 
1651                 theDstCStr[dstCharIndex] = 0;
1652                 
1653                 \hyperlink{_c_p_string_utils_8cpp_a5a59076beb65283c27a32e2a441b83a5}{ConcatCStrToCStr}(theInsertCStrs[theCStrIndex],theDstCStr,theMaxDstStrLength
      );
1654                 
1655                 dstCharIndex = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theDstCStr);
1656                 
1657                 theCStrIndex++;
1658             \}
1659             
1660             \textcolor{comment}{//  Did we find a '%ld'?}
1661             
1662             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (theLongInts != nil && theSrcCStr[srcCharIndex] == \textcolor{charliteral}{'%'} && theSrcCStr[srcCharIndex + 1] 
      == \textcolor{charliteral}{'l'} && theSrcCStr[srcCharIndex + 2] == \textcolor{charliteral}{'d'})
1663             \{
1664                 \textcolor{comment}{//  Skip over the '%ld'}
1665                 
1666                 srcCharIndex += 3;
1667                 
1668                 
1669                 \textcolor{comment}{//  Terminate the dest string and then concat the number}
1670                 
1671                 theDstCStr[dstCharIndex] = 0;
1672                 
1673                 \hyperlink{_c_p_string_utils_8cpp_a58f67ce1b74a750bf1d9d22b87155b7e}{ConcatLongIntToCStr}(theLongInts[theLongIntIndex],theDstCStr,
      theMaxDstStrLength);
1674                 
1675                 theLongIntIndex++;
1676                 
1677                 dstCharIndex = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theDstCStr);
1678             \}
1679             
1680             \textcolor{keywordflow}{else}
1681             \{
1682                 theDstCStr[dstCharIndex++] = theSrcCStr[srcCharIndex++];
1683             \}
1684         \}
1685     \}
1686 
1687 
1688 
1689 EXITPOINT:
1690 
1691     \textcolor{keywordflow}{return};
1692 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a8faf2025c36ae073f7eadea962f29e6c_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a8faf2025c36ae073f7eadea962f29e6c_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+And\+Insert1\+Long\+Int\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert1\+Long\+Int\+Into\+C\+Str}}
\index{Copy\+C\+Str\+And\+Insert1\+Long\+Int\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert1\+Long\+Int\+Into\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+And\+Insert1\+Long\+Int\+Into\+C\+Str(const char $\ast$the\+Src\+C\+Str, const long the\+Num, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)}{CopyCStrAndInsert1LongIntIntoCStr(const char *theSrcCStr, const long theNum, char *theDstCStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+C\+Str\+And\+Insert1\+Long\+Int\+Into\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{const long}]{the\+Num, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a8c2ed6654006f1f60df943b042531f84}{}\label{_c_p_string_utils_8hpp_a8c2ed6654006f1f60df943b042531f84}


Definition at line 1558 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1559 \{
1560     \hyperlink{_c_p_string_utils_8cpp_adaef1a07385d214d2f78f5a795219dd8}{CopyCStrAndInsertCStrLongIntIntoCStr}(theSrcCStr,nil,theNum,
      theDstCStr,maxDstStrLength);
1561 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a8c2ed6654006f1f60df943b042531f84_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+And\+Insert2\+Long\+Ints\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert2\+Long\+Ints\+Into\+C\+Str}}
\index{Copy\+C\+Str\+And\+Insert2\+Long\+Ints\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert2\+Long\+Ints\+Into\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+And\+Insert2\+Long\+Ints\+Into\+C\+Str(const char $\ast$the\+Src\+C\+Str, const long long1, const long long2, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)}{CopyCStrAndInsert2LongIntsIntoCStr(const char *theSrcCStr, const long long1, const long long2, char *theDstCStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+C\+Str\+And\+Insert2\+Long\+Ints\+Into\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{const long}]{long1, }
\item[{const long}]{long2, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ae71298d0eefdc9e0b010f466235aa6a3}{}\label{_c_p_string_utils_8hpp_ae71298d0eefdc9e0b010f466235aa6a3}


Definition at line 1564 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1565 \{
1566 \textcolor{keyword}{const} \textcolor{keywordtype}{long}  theLongInts[] = \{ long1,long2 \};
1567 
1568     \hyperlink{_c_p_string_utils_8cpp_a8faf2025c36ae073f7eadea962f29e6c}{CopyCStrAndInsertCStrsLongIntsIntoCStr}(theSrcCStr,nil,theLongInts
      ,theDstCStr,maxDstStrLength);
1569 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_ae71298d0eefdc9e0b010f466235aa6a3_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+And\+Insert3\+Long\+Ints\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert3\+Long\+Ints\+Into\+C\+Str}}
\index{Copy\+C\+Str\+And\+Insert3\+Long\+Ints\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert3\+Long\+Ints\+Into\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+And\+Insert3\+Long\+Ints\+Into\+C\+Str(const char $\ast$the\+Src\+C\+Str, const long long1, const long long2, const long long3, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)}{CopyCStrAndInsert3LongIntsIntoCStr(const char *theSrcCStr, const long long1, const long long2, const long long3, char *theDstCStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+C\+Str\+And\+Insert3\+Long\+Ints\+Into\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{const long}]{long1, }
\item[{const long}]{long2, }
\item[{const long}]{long3, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a949beaa3c9fad8df4f8f23e619299d65}{}\label{_c_p_string_utils_8hpp_a949beaa3c9fad8df4f8f23e619299d65}


Definition at line 1572 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1573 \{
1574 \textcolor{keyword}{const} \textcolor{keywordtype}{long}  theLongInts[] = \{ long1,long2,long3 \};
1575 
1576     \hyperlink{_c_p_string_utils_8cpp_a8faf2025c36ae073f7eadea962f29e6c}{CopyCStrAndInsertCStrsLongIntsIntoCStr}(theSrcCStr,nil,theLongInts
      ,theDstCStr,maxDstStrLength);
1577 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a949beaa3c9fad8df4f8f23e619299d65_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+C\+Str}}
\index{Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+C\+Str@{Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+C\+Str(const char $\ast$the\+Src\+C\+Str, const char $\ast$the\+Insert\+C\+Str, const long the\+Num, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+Str\+Length)}{CopyCStrAndInsertCStrLongIntIntoCStr(const char *theSrcCStr, const char *theInsertCStr, const long theNum, char *theDstCStr, const int maxDstStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{const char $\ast$}]{the\+Insert\+C\+Str, }
\item[{const long}]{the\+Num, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_adaef1a07385d214d2f78f5a795219dd8}{}\label{_c_p_string_utils_8hpp_adaef1a07385d214d2f78f5a795219dd8}


Definition at line 1589 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1590 \{
1591 \textcolor{keyword}{const} \textcolor{keywordtype}{char}  *theCStrs[2] = \{ theInsertCStr,nil \};
1592 \textcolor{keyword}{const} \textcolor{keywordtype}{long}  theLongInts[1] = \{ theNum \};
1593 
1594     \hyperlink{_c_p_string_utils_8cpp_a8faf2025c36ae073f7eadea962f29e6c}{CopyCStrAndInsertCStrsLongIntsIntoCStr}(theSrcCStr,theCStrs,
      theLongInts,theDstCStr,maxDstStrLength);
1595 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_adaef1a07385d214d2f78f5a795219dd8_cgraph}
\end{center}
\end{figure}




Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_adaef1a07385d214d2f78f5a795219dd8_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+Handle@{Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+Handle}}
\index{Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+Handle@{Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+Handle(const char $\ast$the\+Src\+C\+Str, const char $\ast$the\+Insert\+C\+Str, const long the\+Num, Handle $\ast$the\+Handle)}{CopyCStrAndInsertCStrLongIntIntoHandle(const char *theSrcCStr, const char *theInsertCStr, const long theNum, Handle *theHandle)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Copy\+C\+Str\+And\+Insert\+C\+Str\+Long\+Int\+Into\+Handle (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{const char $\ast$}]{the\+Insert\+C\+Str, }
\item[{const long}]{the\+Num, }
\item[{Handle $\ast$}]{the\+Handle}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a53398520bce3e6afc7fcbb1be7cd0ce7}{}\label{_c_p_string_utils_8hpp_a53398520bce3e6afc7fcbb1be7cd0ce7}


Definition at line 1698 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1699 \{
1700 OSErr   errCode;
1701 \textcolor{keywordtype}{long}    byteCount;
1702 
1703     
1704     \textcolor{keywordflow}{if} (theHandle != nil)
1705     \{
1706         byteCount = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theSrcCStr) + \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theInsertCStr) + 32;
1707         
1708         *theHandle = NewHandle(byteCount);
1709         
1710         \textcolor{keywordflow}{if} (*theHandle == nil)
1711         \{
1712             \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"
      CopyCStrAndInsertCStrLongIntIntoHandle: Can't allocate Handle, MemError() = "},MemError());
1713         \}
1714         
1715         
1716         HLock(*theHandle);
1717         
1718         \hyperlink{_c_p_string_utils_8cpp_adaef1a07385d214d2f78f5a795219dd8}{CopyCStrAndInsertCStrLongIntIntoCStr}(theSrcCStr,theInsertCStr,
      theNum,**theHandle,byteCount);
1719         
1720         HUnlock(*theHandle);
1721     \}
1722     
1723     errCode = noErr;
1724     
1725     
1726 EXITPOINT:
1727 
1728     \textcolor{keywordflow}{return}(errCode);
1729 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a53398520bce3e6afc7fcbb1be7cd0ce7_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+Indexed\+Word\+To\+C\+Str@{Copy\+Indexed\+Word\+To\+C\+Str}}
\index{Copy\+Indexed\+Word\+To\+C\+Str@{Copy\+Indexed\+Word\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+Indexed\+Word\+To\+C\+Str(char $\ast$the\+Src\+C\+Str, int which\+Word, char $\ast$the\+Dst\+C\+Str, int max\+Dst\+C\+Str\+Length)}{CopyIndexedWordToCStr(char *theSrcCStr, int whichWord, char *theDstCStr, int maxDstCStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Copy\+Indexed\+Word\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{the\+Src\+C\+Str, }
\item[{int}]{which\+Word, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{int}]{max\+Dst\+C\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ab44cd05a83904b88ce29f11d96d37e39}{}\label{_c_p_string_utils_8hpp_ab44cd05a83904b88ce29f11d96d37e39}


Definition at line 1735 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1736 \{
1737 OSErr       errCode;
1738 \textcolor{keywordtype}{char}        *srcCharPtr,*dstCharPtr;
1739 \textcolor{keywordtype}{int}         wordCount;
1740 \textcolor{keywordtype}{int}         byteCount;
1741 
1742 
1743     \textcolor{keywordflow}{if} (theSrcCStr == nil)
1744     \{
1745         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedWordToCStr: Bad parameter, theSrcCStr ==
       nil"}));
1746     \}
1747     
1748     \textcolor{keywordflow}{if} (theDstCStr == nil)
1749     \{
1750         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedWordToCStr: Bad parameter, theDstCStr ==
       nil"}));
1751     \}
1752     
1753     \textcolor{keywordflow}{if} (whichWord < 0)
1754     \{
1755         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedWordToCStr: Bad parameter, whichWord < 0"}
      ));
1756     \}
1757     
1758     \textcolor{keywordflow}{if} (maxDstCStrLength <= 0)
1759     \{
1760         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedWordToCStr: Bad parameter,
       maxDstCStrLength <= 0"}));
1761     \}
1762 
1763     
1764     *theDstCStr = \textcolor{charliteral}{'\(\backslash\)0'};
1765     
1766     srcCharPtr = theSrcCStr;
1767 
1768     \textcolor{keywordflow}{while} (*srcCharPtr == \textcolor{charliteral}{' '} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)t'})
1769     \{
1770         srcCharPtr++;
1771     \}
1772     
1773 
1774     \textcolor{keywordflow}{for} (wordCount = 0;wordCount < whichWord;wordCount++)
1775     \{
1776         \textcolor{keywordflow}{while} (*srcCharPtr != \textcolor{charliteral}{' '} && *srcCharPtr != \textcolor{charliteral}{'\(\backslash\)t'} && *srcCharPtr != \textcolor{charliteral}{'\(\backslash\)r'} && *srcCharPtr != \textcolor{charliteral}{'\(\backslash\)n'} && *
      srcCharPtr != \textcolor{charliteral}{'\(\backslash\)0'})
1777         \{
1778             srcCharPtr++;
1779         \}
1780         
1781         \textcolor{keywordflow}{if} (*srcCharPtr == \textcolor{charliteral}{'\(\backslash\)r'} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)n'} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)0'})
1782         \{
1783             errCode = noErr;
1784             
1785             \textcolor{keywordflow}{goto} EXITPOINT;
1786         \}
1787 
1788         \textcolor{keywordflow}{while} (*srcCharPtr == \textcolor{charliteral}{' '} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)t'})
1789         \{
1790             srcCharPtr++;
1791         \}
1792         
1793         \textcolor{keywordflow}{if} (*srcCharPtr == \textcolor{charliteral}{'\(\backslash\)r'} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)n'} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)0'})
1794         \{
1795             errCode = noErr;
1796             
1797             \textcolor{keywordflow}{goto} EXITPOINT;
1798         \}
1799     \}
1800 
1801 
1802     dstCharPtr = theDstCStr;
1803     byteCount = 0;
1804     
1805     
1806     \textcolor{keywordflow}{for}(;;)
1807     \{
1808         \textcolor{keywordflow}{if} (byteCount >= maxDstCStrLength - 1 || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)0'} || *srcCharPtr == \textcolor{charliteral}{' '} || *srcCharPtr 
      == \textcolor{charliteral}{'\(\backslash\)t'} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)r'} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)n'})
1809         \{
1810             *dstCharPtr = \textcolor{charliteral}{'\(\backslash\)0'};
1811             \textcolor{keywordflow}{break};
1812         \}
1813         
1814         *dstCharPtr++ = *srcCharPtr++;
1815         
1816         byteCount++;
1817     \}
1818 
1819 
1820     errCode = noErr;
1821 
1822 
1823 EXITPOINT:
1824 
1825     \textcolor{keywordflow}{return}(errCode);
1826 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+Indexed\+Word\+To\+New\+Handle@{Copy\+Indexed\+Word\+To\+New\+Handle}}
\index{Copy\+Indexed\+Word\+To\+New\+Handle@{Copy\+Indexed\+Word\+To\+New\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+Indexed\+Word\+To\+New\+Handle(char $\ast$the\+Src\+C\+Str, int which\+Word, Handle $\ast$out\+The\+Handle)}{CopyIndexedWordToNewHandle(char *theSrcCStr, int whichWord, Handle *outTheHandle)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Copy\+Indexed\+Word\+To\+New\+Handle (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{the\+Src\+C\+Str, }
\item[{int}]{which\+Word, }
\item[{Handle $\ast$}]{out\+The\+Handle}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ac3c7882205f1aee48563a7b7722b19d2}{}\label{_c_p_string_utils_8hpp_ac3c7882205f1aee48563a7b7722b19d2}


Definition at line 1832 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1833 \{
1834 OSErr       errCode;
1835 \textcolor{keywordtype}{char}        *srcCharPtr;
1836 \textcolor{keywordtype}{int}         wordCount;
1837 \textcolor{keywordtype}{int}         byteCount;
1838 
1839 
1840     \textcolor{keywordflow}{if} (theSrcCStr == nil)
1841     \{
1842         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedWordToNewHandle: Bad parameter,
       theSrcCStr == nil"}));
1843     \}
1844     
1845     \textcolor{keywordflow}{if} (outTheHandle == nil)
1846     \{
1847         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedWordToNewHandle: Bad parameter,
       outTheHandle == nil"}));
1848     \}
1849     
1850     \textcolor{keywordflow}{if} (whichWord < 0)
1851     \{
1852         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedWordToNewHandle: Bad parameter, whichWord
       < 0"}));
1853     \}
1854 
1855     
1856     *outTheHandle = nil;
1857     
1858 
1859     srcCharPtr = theSrcCStr;
1860 
1861     \textcolor{keywordflow}{while} (*srcCharPtr == \textcolor{charliteral}{' '} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)t'})
1862     \{
1863         srcCharPtr++;
1864     \}
1865     
1866 
1867     \textcolor{keywordflow}{for} (wordCount = 0;wordCount < whichWord;wordCount++)
1868     \{
1869         \textcolor{keywordflow}{while} (*srcCharPtr != \textcolor{charliteral}{' '} && *srcCharPtr != \textcolor{charliteral}{'\(\backslash\)t'} && *srcCharPtr != \textcolor{charliteral}{'\(\backslash\)r'} && *srcCharPtr != \textcolor{charliteral}{'\(\backslash\)n'} && *
      srcCharPtr != \textcolor{charliteral}{'\(\backslash\)0'})
1870         \{
1871             srcCharPtr++;
1872         \}
1873         
1874         \textcolor{keywordflow}{if} (*srcCharPtr == \textcolor{charliteral}{'\(\backslash\)r'} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)n'} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)0'})
1875         \{
1876             \textcolor{keywordflow}{break};
1877         \}
1878 
1879         \textcolor{keywordflow}{while} (*srcCharPtr == \textcolor{charliteral}{' '} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)t'})
1880         \{
1881             srcCharPtr++;
1882         \}
1883         
1884         \textcolor{keywordflow}{if} (*srcCharPtr == \textcolor{charliteral}{'\(\backslash\)r'} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)n'} || *srcCharPtr == \textcolor{charliteral}{'\(\backslash\)0'})
1885         \{
1886             \textcolor{keywordflow}{break};
1887         \}
1888     \}
1889 
1890 
1891     \textcolor{keywordflow}{for} (byteCount = 0;;byteCount++)
1892     \{
1893         \textcolor{keywordflow}{if} (srcCharPtr[byteCount] == \textcolor{charliteral}{' '} || srcCharPtr[byteCount] == \textcolor{charliteral}{'\(\backslash\)t'} || srcCharPtr[byteCount] == \textcolor{charliteral}{'\(\backslash\)r'} 
      || srcCharPtr[byteCount] == \textcolor{charliteral}{'\(\backslash\)n'} || srcCharPtr[byteCount] == \textcolor{charliteral}{'\(\backslash\)0'})
1894         \{
1895             \textcolor{keywordflow}{break};
1896         \}
1897     \}
1898 
1899     
1900     *outTheHandle = NewHandle(byteCount + 1);
1901     
1902     \textcolor{keywordflow}{if} (*outTheHandle == nil)
1903     \{
1904         \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"CopyIndexedWordToNewHandle: Can't
       allocate Handle, MemError() = "},MemError());
1905     \}
1906     
1907     
1908     ::BlockMove(srcCharPtr,**outTheHandle,byteCount);
1909     
1910     (**outTheHandle)[byteCount] = \textcolor{charliteral}{'\(\backslash\)0'};
1911 
1912     errCode = noErr;
1913 
1914 
1915 EXITPOINT:
1916 
1917     \textcolor{keywordflow}{return}(errCode);
1918 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+Indexed\+Line\+To\+C\+Str@{Copy\+Indexed\+Line\+To\+C\+Str}}
\index{Copy\+Indexed\+Line\+To\+C\+Str@{Copy\+Indexed\+Line\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+Indexed\+Line\+To\+C\+Str(const char $\ast$the\+Src\+C\+Str, int in\+Which\+Line, int $\ast$line\+End\+Index, Boolean $\ast$got\+Last\+Line, char $\ast$the\+Dst\+C\+Str, const int max\+Dst\+C\+Str\+Length)}{CopyIndexedLineToCStr(const char *theSrcCStr, int inWhichLine, int *lineEndIndex, Boolean *gotLastLine, char *theDstCStr, const int maxDstCStrLength)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Copy\+Indexed\+Line\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{int}]{in\+Which\+Line, }
\item[{int $\ast$}]{line\+End\+Index, }
\item[{Boolean $\ast$}]{got\+Last\+Line, }
\item[{char $\ast$}]{the\+Dst\+C\+Str, }
\item[{const int}]{max\+Dst\+C\+Str\+Length}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_abcbf635e0435f9af4c79150131521182}{}\label{_c_p_string_utils_8hpp_abcbf635e0435f9af4c79150131521182}


Definition at line 1922 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
1923 \{
1924 OSErr       errCode;
1925 \textcolor{keywordtype}{int}         theCurrentLine;
1926 \textcolor{keywordtype}{int}         theCurrentLineOffset;
1927 \textcolor{keywordtype}{int}         theEOSOffset;
1928 
1929 
1930     \textcolor{keywordflow}{if} (theSrcCStr == nil)
1931     \{
1932         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedLineToCStr: Bad parameter, theSrcCStr ==
       nil"}));
1933     \}
1934     
1935     \textcolor{keywordflow}{if} (theDstCStr == nil)
1936     \{
1937         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedLineToCStr: Bad parameter, theDstCStr ==
       nil"}));
1938     \}
1939     
1940     \textcolor{keywordflow}{if} (inWhichLine < 0)
1941     \{
1942         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedLineToCStr: Bad parameter, inWhichLine <
       0"}));
1943     \}
1944     
1945     \textcolor{keywordflow}{if} (maxDstCStrLength <= 0)
1946     \{
1947         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedLineToCStr: Bad parameter,
       maxDstCStrLength <= 0"}));
1948     \}
1949     
1950     
1951     \textcolor{keywordflow}{if} (gotLastLine != nil)
1952     \{
1953         *gotLastLine = \textcolor{keyword}{false};
1954     \}
1955 
1956     
1957     *theDstCStr = 0;
1958     
1959     theCurrentLineOffset = 0;
1960     
1961     theCurrentLine = 0;
1962     
1963     
1964     \textcolor{keywordflow}{while} (theCurrentLine < inWhichLine)
1965     \{
1966         \textcolor{keywordflow}{while} (theSrcCStr[theCurrentLineOffset] != \textcolor{charliteral}{'\(\backslash\)r'} && theSrcCStr[theCurrentLineOffset] != 0)
1967         \{
1968             theCurrentLineOffset++;
1969         \}
1970         
1971         \textcolor{keywordflow}{if} (theSrcCStr[theCurrentLineOffset] == 0)
1972         \{
1973             \textcolor{keywordflow}{break};
1974         \}
1975         
1976         theCurrentLineOffset++;
1977         theCurrentLine++;
1978     \}
1979         
1980     \textcolor{keywordflow}{if} (theSrcCStr[theCurrentLineOffset] == 0)
1981     \{
1982         \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"CopyIndexedLineToCStr: Too few
       lines in source text, can't get line "},inWhichLine);
1983     \}
1984 
1985 
1986     theEOSOffset = \hyperlink{_c_p_string_utils_8cpp_a4982736c8dce59a282040b36b9c9ff21}{FindCharOffsetInCStr}(\textcolor{charliteral}{'\(\backslash\)r'},theSrcCStr + theCurrentLineOffset);
1987     
1988     \textcolor{keywordflow}{if} (theEOSOffset >= 0)
1989     \{
1990         \hyperlink{_c_p_string_utils_8cpp_a807c6804e922fefe659d21f0ac10a751}{CopyCSubstrToCStr}(theSrcCStr + theCurrentLineOffset,theEOSOffset,theDstCStr,
      maxDstCStrLength);
1991         
1992         \textcolor{keywordflow}{if} (gotLastLine != nil)
1993         \{
1994             *gotLastLine = \textcolor{keyword}{false};
1995         \}
1996     
1997         \textcolor{keywordflow}{if} (lineEndIndex != nil)
1998         \{
1999             *lineEndIndex = theEOSOffset;
2000         \}
2001     \}
2002     
2003     \textcolor{keywordflow}{else}
2004     \{
2005         theEOSOffset = \hyperlink{_c_p_string_utils_8cpp_a7bfc8229791c1db249bbe38fbbc4cabf}{CStrLength}(theSrcCStr + theCurrentLineOffset);
2006 
2007         \hyperlink{_c_p_string_utils_8cpp_a807c6804e922fefe659d21f0ac10a751}{CopyCSubstrToCStr}(theSrcCStr + theCurrentLineOffset,theEOSOffset,theDstCStr,
      maxDstCStrLength);
2008         
2009         \textcolor{keywordflow}{if} (gotLastLine != nil)
2010         \{
2011             *gotLastLine = \textcolor{keyword}{true};
2012         \}
2013     
2014         \textcolor{keywordflow}{if} (lineEndIndex != nil)
2015         \{
2016             *lineEndIndex = theEOSOffset;
2017         \}
2018     \}
2019     
2020 
2021     errCode = noErr;
2022 
2023 
2024 EXITPOINT:
2025 
2026     \textcolor{keywordflow}{return}(errCode);
2027 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_abcbf635e0435f9af4c79150131521182_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+Indexed\+Line\+To\+New\+Handle@{Copy\+Indexed\+Line\+To\+New\+Handle}}
\index{Copy\+Indexed\+Line\+To\+New\+Handle@{Copy\+Indexed\+Line\+To\+New\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+Indexed\+Line\+To\+New\+Handle(const char $\ast$the\+Src\+C\+Str, int in\+Which\+Line, Handle $\ast$out\+New\+Handle)}{CopyIndexedLineToNewHandle(const char *theSrcCStr, int inWhichLine, Handle *outNewHandle)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Copy\+Indexed\+Line\+To\+New\+Handle (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{int}]{in\+Which\+Line, }
\item[{Handle $\ast$}]{out\+New\+Handle}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_af904acf8af4f5a77913912abde9d7a90}{}\label{_c_p_string_utils_8hpp_af904acf8af4f5a77913912abde9d7a90}


Definition at line 2031 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2032 \{
2033 OSErr       errCode;
2034 \textcolor{keywordtype}{int}         theCurrentLine;
2035 \textcolor{keywordtype}{int}         theCurrentLineOffset;
2036 \textcolor{keywordtype}{int}         byteCount;
2037 
2038 
2039     \hyperlink{_error_handling_8hpp_a792b7061a295fc6f2a04dc813ebbf6dd}{SetErrorMessageAndBailIfNil}(theSrcCStr,\textcolor{stringliteral}{"CopyIndexedLineToNewHandle: Bad
       parameter, theSrcCStr == nil"});
2040     \hyperlink{_error_handling_8hpp_a792b7061a295fc6f2a04dc813ebbf6dd}{SetErrorMessageAndBailIfNil}(outNewHandle,\textcolor{stringliteral}{"CopyIndexedLineToNewHandle: Bad
       parameter, outNewHandle == nil"});
2041     
2042     \textcolor{keywordflow}{if} (inWhichLine < 0)
2043     \{
2044         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"CopyIndexedLineToNewHandle: Bad parameter,
       inWhichLine < 0"}));
2045     \}
2046     
2047 
2048     theCurrentLineOffset = 0;
2049     
2050     theCurrentLine = 0;
2051     
2052     
2053     \textcolor{keywordflow}{while} (theCurrentLine < inWhichLine)
2054     \{
2055         \textcolor{keywordflow}{while} (theSrcCStr[theCurrentLineOffset] != \textcolor{charliteral}{'\(\backslash\)r'} && theSrcCStr[theCurrentLineOffset] != \textcolor{charliteral}{'\(\backslash\)0'})
2056         \{
2057             theCurrentLineOffset++;
2058         \}
2059         
2060         \textcolor{keywordflow}{if} (theSrcCStr[theCurrentLineOffset] == \textcolor{charliteral}{'\(\backslash\)0'})
2061         \{
2062             \textcolor{keywordflow}{break};
2063         \}
2064         
2065         theCurrentLineOffset++;
2066         theCurrentLine++;
2067     \}
2068         
2069     \textcolor{keywordflow}{if} (theSrcCStr[theCurrentLineOffset] == \textcolor{charliteral}{'\(\backslash\)0'})
2070     \{
2071         \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"CopyIndexedLineToNewHandle: Too
       few lines in source text, can't get line #"},inWhichLine);
2072     \}
2073 
2074     
2075     byteCount = 0;
2076     
2077     \textcolor{keywordflow}{while} (theSrcCStr[theCurrentLineOffset + byteCount] != \textcolor{charliteral}{'\(\backslash\)r'} && theSrcCStr[theCurrentLineOffset + 
      byteCount] != \textcolor{charliteral}{'\(\backslash\)0'})
2078     \{
2079         byteCount++;
2080     \}
2081         
2082     
2083     *outNewHandle = NewHandle(byteCount + 1);
2084     
2085     \textcolor{keywordflow}{if} (*outNewHandle == nil)
2086     \{
2087         \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"CopyIndexedLineToNewHandle: Can't
       allocate Handle, MemError() = "},MemError());
2088     \}
2089     
2090     ::BlockMove(theSrcCStr + theCurrentLineOffset,**outNewHandle,byteCount);
2091     
2092     (**outNewHandle)[byteCount] = \textcolor{charliteral}{'\(\backslash\)0'};
2093 
2094     errCode = noErr;
2095 
2096 
2097 EXITPOINT:
2098 
2099     \textcolor{keywordflow}{return}(errCode);
2100 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Extract\+Int\+From\+C\+Str@{Extract\+Int\+From\+C\+Str}}
\index{Extract\+Int\+From\+C\+Str@{Extract\+Int\+From\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Extract\+Int\+From\+C\+Str(const char $\ast$the\+Src\+C\+Str, int $\ast$out\+Int, Boolean skip\+Leading\+Spaces=true)}{ExtractIntFromCStr(const char *theSrcCStr, int *outInt, Boolean skipLeadingSpaces=true)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Extract\+Int\+From\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{the\+Src\+C\+Str, }
\item[{int $\ast$}]{out\+Int, }
\item[{Boolean}]{skip\+Leading\+Spaces = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a4190f68902f612fc26f82a3e112f7346}{}\label{_c_p_string_utils_8hpp_a4190f68902f612fc26f82a3e112f7346}


Definition at line 2149 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2150 \{
2151 OSErr       errCode;
2152 \textcolor{keywordtype}{int}         theCharIndex;
2153 
2154 
2155     \textcolor{keywordflow}{if} (theSrcCStr == nil)
2156     \{
2157         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"ExtractIntFromCStr: Bad parameter, theSrcCStr == nil
      "}));
2158     \}
2159     
2160     \textcolor{keywordflow}{if} (outInt == nil)
2161     \{
2162         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"ExtractIntFromCStr: Bad parameter, outInt == nil"}));
2163     \}   
2164 
2165     
2166     *outInt = 0;
2167     
2168     theCharIndex = 0;
2169     
2170     \textcolor{keywordflow}{if} (skipLeadingSpaces == \textcolor{keyword}{true})
2171     \{
2172         \textcolor{keywordflow}{while} (theSrcCStr[theCharIndex] == \textcolor{charliteral}{' '})
2173         \{
2174             theCharIndex++;
2175         \}
2176     \}
2177     
2178     \textcolor{keywordflow}{if} (theSrcCStr[theCharIndex] < \textcolor{charliteral}{'0'} || theSrcCStr[theCharIndex] > \textcolor{charliteral}{'9'})
2179     \{
2180         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"ExtractIntFromCStr: Bad parameter, theSrcCStr
       contains a bogus numeric representation"}));
2181     \}
2182 
2183 
2184     \textcolor{keywordflow}{while} (theSrcCStr[theCharIndex] >= \textcolor{charliteral}{'0'} && theSrcCStr[theCharIndex] <= \textcolor{charliteral}{'9'})
2185     \{
2186         *outInt = (*outInt * 10) + (theSrcCStr[theCharIndex] - \textcolor{charliteral}{'0'});
2187         
2188         theCharIndex++;
2189     \}
2190     
2191 
2192     errCode = noErr;
2193 
2194 
2195 EXITPOINT:
2196 
2197     \textcolor{keywordflow}{return}(errCode);
2198 \}
\end{DoxyCode}


Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=319pt]{_c_p_string_utils_8hpp_a4190f68902f612fc26f82a3e112f7346_icgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Extract\+Int\+From\+P\+Str@{Extract\+Int\+From\+P\+Str}}
\index{Extract\+Int\+From\+P\+Str@{Extract\+Int\+From\+P\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Extract\+Int\+From\+P\+Str(const unsigned char $\ast$the\+Src\+P\+Str, int $\ast$out\+Int, Boolean skip\+Leading\+Spaces=true)}{ExtractIntFromPStr(const unsigned char *theSrcPStr, int *outInt, Boolean skipLeadingSpaces=true)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Extract\+Int\+From\+P\+Str (
\begin{DoxyParamCaption}
\item[{const unsigned char $\ast$}]{the\+Src\+P\+Str, }
\item[{int $\ast$}]{out\+Int, }
\item[{Boolean}]{skip\+Leading\+Spaces = {\ttfamily true}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_aaea0259b4d9390434101fde8d2e91ac7}{}\label{_c_p_string_utils_8hpp_aaea0259b4d9390434101fde8d2e91ac7}


Definition at line 2202 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2203 \{
2204 OSErr       errCode;
2205 \textcolor{keywordtype}{char}        theCStr[256];
2206 
2207 
2208     \textcolor{keywordflow}{if} (theSrcPStr == nil)
2209     \{
2210         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"ExtractIntFromPStr: Bad parameter, theSrcPStr == nil
      "}));
2211     \}
2212     
2213     \textcolor{keywordflow}{if} (outInt == nil)
2214     \{
2215         \hyperlink{_error_handling_8hpp_ae11c756a09c19ce3cc6a62107eb31995}{SetErrorMessageAndBail}((\textcolor{stringliteral}{"ExtractIntFromPStr: Bad parameter, outInt == nil"}));
2216     \}
2217     
2218     
2219     \hyperlink{_c_p_string_utils_8cpp_aa3d21c3114a0a989f06c86d78d4d10c2}{CopyPStrToCStr}(theSrcPStr,theCStr,\textcolor{keyword}{sizeof}(theCStr));
2220     
2221     
2222     errCode = \hyperlink{_c_p_string_utils_8cpp_a69fed72123393402a23d01c80492320e}{ExtractIntFromCStr}(theCStr,outInt,skipLeadingSpaces);
2223 
2224 
2225 EXITPOINT:
2226 
2227     \textcolor{keywordflow}{return}(errCode);
2228 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=319pt]{_c_p_string_utils_8hpp_aaea0259b4d9390434101fde8d2e91ac7_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Convert\+C\+Str\+To\+Upper\+Case@{Convert\+C\+Str\+To\+Upper\+Case}}
\index{Convert\+C\+Str\+To\+Upper\+Case@{Convert\+C\+Str\+To\+Upper\+Case}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Convert\+C\+Str\+To\+Upper\+Case(char $\ast$the\+Src\+C\+Str)}{ConvertCStrToUpperCase(char *theSrcCStr)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Convert\+C\+Str\+To\+Upper\+Case (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{the\+Src\+C\+Str}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_aa5d5794d7ab06d3213420553a445fd96}{}\label{_c_p_string_utils_8hpp_aa5d5794d7ab06d3213420553a445fd96}


Definition at line 2293 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2294 \{
2295 \textcolor{keywordtype}{char}        *theCharPtr;
2296 
2297 
2298     \textcolor{keywordflow}{if} (theSrcCStr != nil)
2299     \{
2300         theCharPtr = theSrcCStr;
2301         
2302         \textcolor{keywordflow}{while} (*theCharPtr != 0)
2303         \{
2304             \textcolor{keywordflow}{if} (*theCharPtr >= \textcolor{charliteral}{'a'} && *theCharPtr <= \textcolor{charliteral}{'z'})
2305             \{
2306                 *theCharPtr = *theCharPtr - \textcolor{charliteral}{'a'} + \textcolor{charliteral}{'A'};
2307             \}
2308             
2309             theCharPtr++;
2310         \}
2311     \}
2312 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Count\+Occurences\+Of\+Char\+In\+C\+Str@{Count\+Occurences\+Of\+Char\+In\+C\+Str}}
\index{Count\+Occurences\+Of\+Char\+In\+C\+Str@{Count\+Occurences\+Of\+Char\+In\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Count\+Occurences\+Of\+Char\+In\+C\+Str(const char in\+Char, const char $\ast$in\+Src\+C\+Str)}{CountOccurencesOfCharInCStr(const char inChar, const char *inSrcCStr)}}]{\setlength{\rightskip}{0pt plus 5cm}int Count\+Occurences\+Of\+Char\+In\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char}]{in\+Char, }
\item[{const char $\ast$}]{in\+Src\+C\+Str}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_abb80d5287721e3f8a2489ea5a654e807}{}\label{_c_p_string_utils_8hpp_abb80d5287721e3f8a2489ea5a654e807}


Definition at line 2232 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2233 \{
2234 \textcolor{keywordtype}{int}     theSrcCharIndex;
2235 \textcolor{keywordtype}{int}     numOccurrences = -1;
2236 
2237 
2238     \textcolor{keywordflow}{if} (inSrcCStr != nil && inChar != \textcolor{charliteral}{'\(\backslash\)0'})
2239     \{
2240         numOccurrences = 0;
2241         
2242         \textcolor{keywordflow}{for} (theSrcCharIndex = 0;inSrcCStr[theSrcCharIndex] != \textcolor{charliteral}{'\(\backslash\)0'};theSrcCharIndex++)
2243         \{
2244             \textcolor{keywordflow}{if} (inSrcCStr[theSrcCharIndex] == inChar)
2245             \{
2246                 numOccurrences++;
2247             \}
2248         \}
2249     \}
2250     
2251     \textcolor{keywordflow}{return}(numOccurrences);
2252 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Count\+Words\+In\+C\+Str@{Count\+Words\+In\+C\+Str}}
\index{Count\+Words\+In\+C\+Str@{Count\+Words\+In\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Count\+Words\+In\+C\+Str(const char $\ast$in\+Src\+C\+Str)}{CountWordsInCStr(const char *inSrcCStr)}}]{\setlength{\rightskip}{0pt plus 5cm}int Count\+Words\+In\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{in\+Src\+C\+Str}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a0f0ac60c0dcb10ca46d7db923d0bc1a7}{}\label{_c_p_string_utils_8hpp_a0f0ac60c0dcb10ca46d7db923d0bc1a7}


Definition at line 2255 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2256 \{
2257 \textcolor{keywordtype}{int}     numWords = -1;
2258 
2259 
2260     \textcolor{keywordflow}{if} (inSrcCStr != nil)
2261     \{
2262         numWords = 0;
2263         
2264         \textcolor{comment}{//  Skip lead spaces}
2265         
2266         \textcolor{keywordflow}{while} (*inSrcCStr == \textcolor{charliteral}{' '})
2267         \{
2268             inSrcCStr++;
2269         \}
2270 
2271         \textcolor{keywordflow}{while} (*inSrcCStr != \textcolor{charliteral}{'\(\backslash\)0'})
2272         \{
2273             numWords++;
2274 
2275             \textcolor{keywordflow}{while} (*inSrcCStr != \textcolor{charliteral}{' '} && *inSrcCStr != \textcolor{charliteral}{'\(\backslash\)0'})
2276             \{
2277                 inSrcCStr++;
2278             \}
2279             
2280             \textcolor{keywordflow}{while} (*inSrcCStr == \textcolor{charliteral}{' '})
2281             \{
2282                 inSrcCStr++;
2283             \}
2284         \}
2285     \}
2286     
2287     \textcolor{keywordflow}{return}(numWords);
2288 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Count\+Digits@{Count\+Digits}}
\index{Count\+Digits@{Count\+Digits}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Count\+Digits(const char $\ast$in\+C\+Str, int $\ast$out\+Num\+Integer\+Digits, int $\ast$out\+Num\+Fract\+Digits)}{CountDigits(const char *inCStr, int *outNumIntegerDigits, int *outNumFractDigits)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Count\+Digits (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{in\+C\+Str, }
\item[{int $\ast$}]{out\+Num\+Integer\+Digits, }
\item[{int $\ast$}]{out\+Num\+Fract\+Digits}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_aad874ee4f97a91280c4c448966b44655}{}\label{_c_p_string_utils_8hpp_aad874ee4f97a91280c4c448966b44655}


Definition at line 2105 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2106 \{
2107 OSErr   errCode = noErr;
2108 \textcolor{keywordtype}{int}     numIntDigits = 0;
2109 \textcolor{keywordtype}{int}     numFractDigits = 0;
2110 \textcolor{keywordtype}{int}     digitIndex = 0;
2111 
2112     
2113     \hyperlink{_error_handling_8hpp_a792b7061a295fc6f2a04dc813ebbf6dd}{SetErrorMessageAndBailIfNil}(inCStr,\textcolor{stringliteral}{"CountDigits: Bad parameter, theSrcCStr
       == nil"});
2114     \hyperlink{_error_handling_8hpp_a792b7061a295fc6f2a04dc813ebbf6dd}{SetErrorMessageAndBailIfNil}(outNumIntegerDigits,\textcolor{stringliteral}{"CountDigits: Bad parameter,
       outNumIntegerDigits == nil"});
2115     \hyperlink{_error_handling_8hpp_a792b7061a295fc6f2a04dc813ebbf6dd}{SetErrorMessageAndBailIfNil}(outNumFractDigits,\textcolor{stringliteral}{"CountDigits: Bad parameter,
       outNumFractDigits == nil"});
2116     
2117     digitIndex = 0;
2118     
2119     \textcolor{keywordflow}{while} (inCStr[digitIndex] >= \textcolor{charliteral}{'0'} && inCStr[digitIndex] <= \textcolor{charliteral}{'9'})
2120     \{
2121         digitIndex++;
2122         numIntDigits++;
2123     \}
2124     
2125     \textcolor{keywordflow}{if} (inCStr[digitIndex] == \textcolor{charliteral}{'.'})
2126     \{
2127         digitIndex++;
2128         
2129         \textcolor{keywordflow}{while} (inCStr[digitIndex] >= \textcolor{charliteral}{'0'} && inCStr[digitIndex] <= \textcolor{charliteral}{'9'})
2130         \{
2131             digitIndex++;
2132             numFractDigits++;
2133         \}
2134     \}
2135     
2136     *outNumIntegerDigits = numIntDigits;
2137     
2138     *outNumFractDigits = numFractDigits;
2139     
2140     errCode = noErr;
2141     
2142 EXITPOINT:
2143 
2144     \textcolor{keywordflow}{return}(errCode);
2145 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Extract\+C\+Str\+Item\+From\+C\+Str@{Extract\+C\+Str\+Item\+From\+C\+Str}}
\index{Extract\+C\+Str\+Item\+From\+C\+Str@{Extract\+C\+Str\+Item\+From\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Extract\+C\+Str\+Item\+From\+C\+Str(const char $\ast$in\+Src\+C\+Str, const char in\+Item\+Delimiter, const int in\+Item\+Number, Boolean $\ast$found\+Item, char $\ast$out\+Dst\+Char\+Ptr, const int in\+Dst\+Char\+Ptr\+Max\+Length, const Boolean in\+Treat\+Multiple\+Delims\+As\+Single\+Delim=false)}{ExtractCStrItemFromCStr(const char *inSrcCStr, const char inItemDelimiter, const int inItemNumber, Boolean *foundItem, char *outDstCharPtr, const int inDstCharPtrMaxLength, const Boolean inTreatMultipleDelimsAsSingleDelim=false)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Extract\+C\+Str\+Item\+From\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{in\+Src\+C\+Str, }
\item[{const char}]{in\+Item\+Delimiter, }
\item[{const int}]{in\+Item\+Number, }
\item[{Boolean $\ast$}]{found\+Item, }
\item[{char $\ast$}]{out\+Dst\+Char\+Ptr, }
\item[{const int}]{in\+Dst\+Char\+Ptr\+Max\+Length, }
\item[{const Boolean}]{in\+Treat\+Multiple\+Delims\+As\+Single\+Delim = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a6021ef8ab42d6c0c19a952877372c628}{}\label{_c_p_string_utils_8hpp_a6021ef8ab42d6c0c19a952877372c628}


Definition at line 2320 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2321 \{
2322 \textcolor{keywordtype}{int}     theItem;
2323 \textcolor{keywordtype}{int}     theSrcCharIndex;
2324 \textcolor{keywordtype}{int}     theDstCharIndex;
2325 
2326 
2327     \textcolor{keywordflow}{if} (foundItem != nil)
2328     \{
2329         *foundItem = \textcolor{keyword}{false};
2330     \}
2331     
2332     
2333     \textcolor{keywordflow}{if} (outDstCharPtr != nil && inDstCharPtrMaxLength > 0 && inItemNumber >= 0 && inItemDelimiter != 0)
2334     \{
2335         *outDstCharPtr = 0;
2336         
2337 
2338         theSrcCharIndex = 0;
2339         
2340         \textcolor{keywordflow}{for} (theItem = 0;theItem < inItemNumber;theItem++)
2341         \{
2342             \textcolor{keywordflow}{while} (inSrcCStr[theSrcCharIndex] != inItemDelimiter && inSrcCStr[theSrcCharIndex] != \textcolor{charliteral}{'\(\backslash\)0'})
2343             \{
2344                 theSrcCharIndex++;
2345             \}
2346             
2347             \textcolor{keywordflow}{if} (inSrcCStr[theSrcCharIndex] == inItemDelimiter)
2348             \{
2349                 theSrcCharIndex++;
2350                 
2351                 \textcolor{keywordflow}{if} (inTreatMultipleDelimsAsSingleDelim)
2352                 \{
2353                     \textcolor{keywordflow}{while} (inSrcCStr[theSrcCharIndex] == inItemDelimiter)
2354                     \{
2355                         theSrcCharIndex++;
2356                     \}
2357                 \}
2358             \}
2359             
2360             
2361             \textcolor{keywordflow}{if} (inSrcCStr[theSrcCharIndex] == \textcolor{charliteral}{'\(\backslash\)0'})
2362             \{
2363                 \textcolor{keywordflow}{goto} EXITPOINT;
2364             \}
2365         \}
2366         
2367 
2368         \textcolor{keywordflow}{if} (foundItem != nil)
2369         \{
2370             *foundItem = \textcolor{keyword}{true};
2371         \}
2372         
2373         
2374         theDstCharIndex = 0;
2375         
2376         \textcolor{keywordflow}{for} (;;)
2377         \{
2378             \textcolor{keywordflow}{if} (inSrcCStr[theSrcCharIndex] == 0 || inSrcCStr[theSrcCharIndex] == inItemDelimiter || 
      theDstCharIndex >= inDstCharPtrMaxLength - 1)
2379             \{
2380                 outDstCharPtr[theDstCharIndex] = 0;
2381                 
2382                 \textcolor{keywordflow}{break};
2383             \}
2384             
2385             outDstCharPtr[theDstCharIndex++] = inSrcCStr[theSrcCharIndex++];
2386         \}
2387     \}
2388     
2389     
2390 EXITPOINT:
2391 
2392     \textcolor{keywordflow}{return};
2393 \}
\end{DoxyCode}
\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Extract\+C\+Str\+Item\+From\+C\+Str\+Into\+New\+Handle@{Extract\+C\+Str\+Item\+From\+C\+Str\+Into\+New\+Handle}}
\index{Extract\+C\+Str\+Item\+From\+C\+Str\+Into\+New\+Handle@{Extract\+C\+Str\+Item\+From\+C\+Str\+Into\+New\+Handle}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Extract\+C\+Str\+Item\+From\+C\+Str\+Into\+New\+Handle(const char $\ast$in\+Src\+C\+Str, const char in\+Item\+Delimiter, const int in\+Item\+Number, Boolean $\ast$found\+Item, Handle $\ast$out\+New\+Handle, const Boolean in\+Treat\+Multiple\+Delims\+As\+Single\+Delim=false)}{ExtractCStrItemFromCStrIntoNewHandle(const char *inSrcCStr, const char inItemDelimiter, const int inItemNumber, Boolean *foundItem, Handle *outNewHandle, const Boolean inTreatMultipleDelimsAsSingleDelim=false)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Extract\+C\+Str\+Item\+From\+C\+Str\+Into\+New\+Handle (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{in\+Src\+C\+Str, }
\item[{const char}]{in\+Item\+Delimiter, }
\item[{const int}]{in\+Item\+Number, }
\item[{Boolean $\ast$}]{found\+Item, }
\item[{Handle $\ast$}]{out\+New\+Handle, }
\item[{const Boolean}]{in\+Treat\+Multiple\+Delims\+As\+Single\+Delim = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_ac077bf309a36ead01c50a622b2fb8a44}{}\label{_c_p_string_utils_8hpp_ac077bf309a36ead01c50a622b2fb8a44}


Definition at line 2397 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2398 \{
2399 OSErr   errCode;
2400 \textcolor{keywordtype}{int}     theItem;
2401 \textcolor{keywordtype}{int}     theSrcCharIndex;
2402 \textcolor{keywordtype}{int}     theItemLength;
2403 
2404 
2405     \textcolor{keywordflow}{if} (inSrcCStr == nil)
2406     \{
2407         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"ExtractCStrItemFromCStrIntoNewHandle: Bad parameter, inSrcCStr ==
       nil"});
2408         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2409         \textcolor{keywordflow}{goto} EXITPOINT;
2410     \}
2411     
2412     \textcolor{keywordflow}{if} (outNewHandle == nil)
2413     \{
2414         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"ExtractCStrItemFromCStrIntoNewHandle: Bad parameter, outNewHandle
       == nil"});
2415         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2416         \textcolor{keywordflow}{goto} EXITPOINT;
2417     \}
2418     
2419     \textcolor{keywordflow}{if} (foundItem == nil)
2420     \{
2421         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"ExtractCStrItemFromCStrIntoNewHandle: Bad parameter, foundItem ==
       nil"});
2422         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2423         \textcolor{keywordflow}{goto} EXITPOINT;
2424     \}
2425     
2426     \textcolor{keywordflow}{if} (inItemNumber < 0)
2427     \{
2428         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"ExtractCStrItemFromCStrIntoNewHandle: Bad parameter, inItemNumber <
       0"});
2429         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2430         \textcolor{keywordflow}{goto} EXITPOINT;
2431     \}
2432     
2433     \textcolor{keywordflow}{if} (inItemDelimiter == 0)
2434     \{
2435         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"ExtractCStrItemFromCStrIntoNewHandle: Bad parameter,
       inItemDelimiter == 0"});
2436         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2437         \textcolor{keywordflow}{goto} EXITPOINT;
2438     \}
2439 
2440 
2441     *foundItem = \textcolor{keyword}{false};
2442     
2443     theSrcCharIndex = 0;
2444     
2445     \textcolor{keywordflow}{for} (theItem = 0;theItem < inItemNumber;theItem++)
2446     \{
2447         \textcolor{keywordflow}{while} (inSrcCStr[theSrcCharIndex] != inItemDelimiter && inSrcCStr[theSrcCharIndex] != \textcolor{charliteral}{'\(\backslash\)0'})
2448         \{
2449             theSrcCharIndex++;
2450         \}
2451         
2452         \textcolor{keywordflow}{if} (inSrcCStr[theSrcCharIndex] == inItemDelimiter)
2453         \{
2454             theSrcCharIndex++;
2455             
2456             \textcolor{keywordflow}{if} (inTreatMultipleDelimsAsSingleDelim)
2457             \{
2458                 \textcolor{keywordflow}{while} (inSrcCStr[theSrcCharIndex] == inItemDelimiter)
2459                 \{
2460                     theSrcCharIndex++;
2461                 \}
2462             \}
2463         \}
2464         
2465         
2466         \textcolor{keywordflow}{if} (inSrcCStr[theSrcCharIndex] == \textcolor{charliteral}{'\(\backslash\)0'})
2467         \{
2468             errCode = noErr;
2469             
2470             \textcolor{keywordflow}{goto} EXITPOINT;
2471         \}
2472     \}
2473     
2474 
2475     *foundItem = \textcolor{keyword}{true};
2476     
2477     
2478     \textcolor{keywordflow}{for} (theItemLength = 0;;theItemLength++)
2479     \{
2480         \textcolor{keywordflow}{if} (inSrcCStr[theSrcCharIndex + theItemLength] == 0 || inSrcCStr[theSrcCharIndex + theItemLength] 
      == inItemDelimiter)
2481         \{
2482             \textcolor{keywordflow}{break};
2483         \}
2484     \}
2485     
2486 
2487     *outNewHandle = NewHandle(theItemLength + 1);
2488     
2489     \textcolor{keywordflow}{if} (*outNewHandle == nil)
2490     \{
2491         \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"
      ExtractCStrItemFromCStrIntoNewHandle: Can't allocate Handle, MemError() = "},MemError());
2492     \}
2493     
2494     
2495     BlockMove(inSrcCStr + theSrcCharIndex,**outNewHandle,theItemLength);
2496     
2497     (**outNewHandle)[theItemLength] = 0;
2498     
2499     errCode = noErr;
2500     
2501     
2502 EXITPOINT:
2503 
2504     \textcolor{keywordflow}{return}(errCode);
2505 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_ac077bf309a36ead01c50a622b2fb8a44_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Extract\+Float\+From\+C\+Str@{Extract\+Float\+From\+C\+Str}}
\index{Extract\+Float\+From\+C\+Str@{Extract\+Float\+From\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Extract\+Float\+From\+C\+Str(const char $\ast$in\+C\+String, extended80 $\ast$out\+Float)}{ExtractFloatFromCStr(const char *inCString, extended80 *outFloat)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Extract\+Float\+From\+C\+Str (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{in\+C\+String, }
\item[{extended80 $\ast$}]{out\+Float}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a68689b7b415bcd3ddad4f1185a0255e0}{}\label{_c_p_string_utils_8hpp_a68689b7b415bcd3ddad4f1185a0255e0}


Definition at line 2512 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2513 \{
2514 OSErr               errCode;
2515 Str255              theStr255;
2516 Handle              theNumberPartsTableHandle = nil;
2517 \textcolor{keywordtype}{long}                theNumberPartsOffset,theNumberPartsLength;
2518 FormatResultType    theFormatResultType;
2519 NumberParts         theNumberPartsTable;
2520 NumFormatStringRec  theNumFormatStringRec;
2521 
2522 
2523     \textcolor{keywordflow}{if} (inCString == nil)
2524     \{
2525         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"ExtractFloatFromCStr: Bad parameter, inCString == nil"});
2526         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2527         \textcolor{keywordflow}{goto} EXITPOINT;
2528     \}
2529 
2530     \textcolor{keywordflow}{if} (outFloat == nil)
2531     \{
2532         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"ExtractFloatFromCStr: Bad parameter, outFloat == nil"});
2533         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2534         \textcolor{keywordflow}{goto} EXITPOINT;
2535     \}
2536     
2537     
2538 \textcolor{comment}{//  
      GetIntlResourceTable(smRoman,smNumberPartsTable,&theNumberPartsTableHandle,&theNumberPartsOffset,&theNumberPartsLength);}
2539 
2540     GetIntlResourceTable(GetScriptManagerVariable(smSysScript),smNumberPartsTable,&
      theNumberPartsTableHandle,&theNumberPartsOffset,&theNumberPartsLength);  
2541     
2542     \textcolor{keywordflow}{if} (theNumberPartsTableHandle == nil)
2543     \{
2544         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"ExtractFloatFromCStr: Can't get number parts table for converting
       string representations to/from numeric representations"});
2545         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2546         \textcolor{keywordflow}{goto} EXITPOINT;
2547     \}
2548     
2549     \textcolor{keywordflow}{if} (theNumberPartsLength > \textcolor{keyword}{sizeof}(theNumberPartsTable))
2550     \{
2551         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"ExtractFloatFromCStr: Number parts table has bad length"});
2552         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2553         \textcolor{keywordflow}{goto} EXITPOINT;
2554     \}
2555     
2556 
2557     BlockMove(*theNumberPartsTableHandle + theNumberPartsOffset,&theNumberPartsTable,theNumberPartsLength);
2558     
2559     
2560     theFormatResultType = (FormatResultType) StringToFormatRec(
      \hyperlink{_c_p_string_utils_8cpp_a52f8f40180788103a851bd52ae166713}{kNumberFormatString},&theNumberPartsTable,&theNumFormatStringRec);
2561     
2562     \textcolor{keywordflow}{if} (theFormatResultType != fFormatOK)
2563     \{
2564         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"ExtractFloatFromCStr: StringToFormatRec() != fFormatOK"});
2565         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2566         \textcolor{keywordflow}{goto} EXITPOINT;
2567     \}
2568 
2569     
2570     \hyperlink{_c_p_string_utils_8cpp_a7f0f18d1bcacabcb386d67a202a62306}{CopyCStrToPStr}(inCString,theStr255,\textcolor{keyword}{sizeof}(theStr255));
2571 
2572 
2573     theFormatResultType = (FormatResultType) StringToExtended(theStr255,&theNumFormatStringRec,&
      theNumberPartsTable,outFloat);
2574     
2575     \textcolor{keywordflow}{if} (theFormatResultType != fFormatOK && theFormatResultType != fBestGuess)
2576     \{
2577         \hyperlink{_error_handling_8hpp_abbc2f61b7f1a165c23ee9ce9110d7bf5}{SetErrorMessageAndLongIntAndBail}(\textcolor{stringliteral}{"ExtractFloatFromCStr:
       StringToExtended() = "},theFormatResultType);
2578     \}
2579 
2580     
2581     errCode = noErr;
2582     
2583 
2584 EXITPOINT:
2585     
2586     \textcolor{keywordflow}{return}(errCode);
2587 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a68689b7b415bcd3ddad4f1185a0255e0_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Copy\+Float\+To\+C\+Str@{Copy\+Float\+To\+C\+Str}}
\index{Copy\+Float\+To\+C\+Str@{Copy\+Float\+To\+C\+Str}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Copy\+Float\+To\+C\+Str(const extended80 $\ast$the\+Float, char $\ast$the\+C\+Str, const int max\+C\+Str\+Length, const int in\+Max\+Num\+Int\+Digits=-\/1, const int in\+Max\+Num\+Fract\+Digits=-\/1)}{CopyFloatToCStr(const extended80 *theFloat, char *theCStr, const int maxCStrLength, const int inMaxNumIntDigits=-1, const int inMaxNumFractDigits=-1)}}]{\setlength{\rightskip}{0pt plus 5cm}O\+S\+Err Copy\+Float\+To\+C\+Str (
\begin{DoxyParamCaption}
\item[{const extended80 $\ast$}]{the\+Float, }
\item[{char $\ast$}]{the\+C\+Str, }
\item[{const int}]{max\+C\+Str\+Length, }
\item[{const int}]{in\+Max\+Num\+Int\+Digits = {\ttfamily -\/1}, }
\item[{const int}]{in\+Max\+Num\+Fract\+Digits = {\ttfamily -\/1}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a3309362121ed5ada320dc570bd2315da}{}\label{_c_p_string_utils_8hpp_a3309362121ed5ada320dc570bd2315da}


Definition at line 2591 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2592 \{
2593 OSErr               errCode;
2594 Str255              theStr255;
2595 Handle              theNumberPartsTableHandle = nil;
2596 \textcolor{keywordtype}{long}                theNumberPartsOffset,theNumberPartsLength;
2597 FormatResultType    theFormatResultType;
2598 NumberParts         theNumberPartsTable;
2599 NumFormatStringRec  theNumFormatStringRec;
2600 
2601 
2602     \textcolor{keywordflow}{if} (theCStr == nil)
2603     \{
2604         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"CopyFloatToCStr: Bad parameter, theCStr == nil"});
2605         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2606         \textcolor{keywordflow}{goto} EXITPOINT;
2607     \}
2608 
2609     \textcolor{keywordflow}{if} (theFloat == nil)
2610     \{
2611         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"CopyFloatToCStr: Bad parameter, theFloat == nil"});
2612         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2613         \textcolor{keywordflow}{goto} EXITPOINT;
2614     \}
2615     
2616 
2617 \textcolor{comment}{//  
      GetIntlResourceTable(smRoman,smNumberPartsTable,&theNumberPartsTableHandle,&theNumberPartsOffset,&theNumberPartsLength);}
2618 
2619     GetIntlResourceTable(GetScriptManagerVariable(smSysScript),smNumberPartsTable,&
      theNumberPartsTableHandle,&theNumberPartsOffset,&theNumberPartsLength);  
2620     
2621     \textcolor{keywordflow}{if} (theNumberPartsTableHandle == nil)
2622     \{
2623         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"CopyFloatToCStr: Can't get number parts table for converting string
       representations to/from numeric representations"});
2624         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2625         \textcolor{keywordflow}{goto} EXITPOINT;
2626     \}
2627     
2628     \textcolor{keywordflow}{if} (theNumberPartsLength > \textcolor{keyword}{sizeof}(theNumberPartsTable))
2629     \{
2630         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"CopyFloatToCStr: Number parts table has bad length"});
2631         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2632         \textcolor{keywordflow}{goto} EXITPOINT;
2633     \}
2634     
2635     
2636     BlockMove(*theNumberPartsTableHandle + theNumberPartsOffset,&theNumberPartsTable,theNumberPartsLength);
2637     
2638     
2639     \textcolor{keywordflow}{if} (inMaxNumIntDigits >= 0 || inMaxNumFractDigits >= 0)
2640     \{
2641     \textcolor{keywordtype}{char}    numberFormat[64];
2642     \textcolor{keywordtype}{int}     numberFormatLength = 0;
2643     
2644         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0;i < inMaxNumIntDigits && numberFormatLength < \textcolor{keyword}{sizeof}(numberFormat) - 1;i++)
2645         \{
2646             numberFormat[numberFormatLength++] = \textcolor{charliteral}{'0'};
2647         \}
2648         
2649         \textcolor{keywordflow}{if} (inMaxNumFractDigits > 0 && numberFormatLength < \textcolor{keyword}{sizeof}(numberFormat) - 1)
2650         \{
2651             numberFormat[numberFormatLength++] = \textcolor{charliteral}{'.'};
2652             
2653             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0;i < inMaxNumFractDigits && numberFormatLength < \textcolor{keyword}{sizeof}(numberFormat) - 1;i++)
2654             \{
2655                 numberFormat[numberFormatLength++] = \textcolor{charliteral}{'0'};
2656             \}
2657         \}
2658 
2659         
2660         \textcolor{keywordflow}{if} (numberFormatLength < \textcolor{keyword}{sizeof}(numberFormat) - 1)
2661         \{
2662             numberFormat[numberFormatLength++] = \textcolor{charliteral}{';'};
2663         \}
2664         
2665         \textcolor{keywordflow}{if} (numberFormatLength < \textcolor{keyword}{sizeof}(numberFormat) - 1)
2666         \{
2667             numberFormat[numberFormatLength++] = \textcolor{charliteral}{'-'};
2668         \}
2669         
2670 
2671         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0;i < inMaxNumIntDigits && numberFormatLength < \textcolor{keyword}{sizeof}(numberFormat) - 1;i++)
2672         \{
2673             numberFormat[numberFormatLength++] = \textcolor{charliteral}{'0'};
2674         \}
2675         
2676         \textcolor{keywordflow}{if} (inMaxNumFractDigits > 0 && numberFormatLength < \textcolor{keyword}{sizeof}(numberFormat) - 1)
2677         \{
2678             numberFormat[numberFormatLength++] = \textcolor{charliteral}{'.'};
2679             
2680             \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0;i < inMaxNumFractDigits && numberFormatLength < \textcolor{keyword}{sizeof}(numberFormat) - 1;i++)
2681             \{
2682                 numberFormat[numberFormatLength++] = \textcolor{charliteral}{'0'};
2683             \}
2684         \}
2685         
2686         numberFormat[numberFormatLength] = \textcolor{charliteral}{'\(\backslash\)0'};
2687 
2688 
2689     Str255  tempStr255;
2690     
2691         \hyperlink{_c_p_string_utils_8cpp_a7f0f18d1bcacabcb386d67a202a62306}{CopyCStrToPStr}(numberFormat,tempStr255,\textcolor{keyword}{sizeof}(tempStr255));
2692         
2693         theFormatResultType = (FormatResultType) StringToFormatRec(tempStr255,&theNumberPartsTable,&
      theNumFormatStringRec);
2694     \}
2695     
2696     \textcolor{keywordflow}{else}
2697     \{
2698         theFormatResultType = (FormatResultType) StringToFormatRec(
      \hyperlink{_c_p_string_utils_8cpp_a52f8f40180788103a851bd52ae166713}{kNumberFormatString},&theNumberPartsTable,&theNumFormatStringRec);
2699     \}
2700     
2701     \textcolor{keywordflow}{if} (theFormatResultType != fFormatOK)
2702     \{
2703         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"CopyFloatToCStr: StringToFormatRec() != fFormatOK"});
2704         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2705         \textcolor{keywordflow}{goto} EXITPOINT;
2706     \}
2707 
2708 
2709     theFormatResultType = (FormatResultType) ExtendedToString(theFloat,&theNumFormatStringRec,&
      theNumberPartsTable,theStr255);
2710     
2711     \textcolor{keywordflow}{if} (theFormatResultType != fFormatOK)
2712     \{
2713         \hyperlink{_error_handling_8cpp_a42692e854659d20b3d19640c4f9dd528}{SetErrorMessage}(\textcolor{stringliteral}{"CopyFloatToCStr: ExtendedToString() != fFormatOK"});
2714         errCode = \hyperlink{_error_handling_8hpp_a112d8687e6f03aa5cf32025e0e1998f0}{kGenericError};
2715         \textcolor{keywordflow}{goto} EXITPOINT;
2716     \}
2717 
2718     
2719     \hyperlink{_c_p_string_utils_8cpp_aa3d21c3114a0a989f06c86d78d4d10c2}{CopyPStrToCStr}(theStr255,theCStr,maxCStrLength);
2720     
2721     errCode = noErr;
2722     
2723 
2724 EXITPOINT:
2725     
2726     \textcolor{keywordflow}{return}(errCode);
2727 \}
\end{DoxyCode}


Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{_c_p_string_utils_8hpp_a3309362121ed5ada320dc570bd2315da_cgraph}
\end{center}
\end{figure}


\index{C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}!Skip\+White\+Space@{Skip\+White\+Space}}
\index{Skip\+White\+Space@{Skip\+White\+Space}!C\+P\+String\+Utils.\+hpp@{C\+P\+String\+Utils.\+hpp}}
\subsubsection[{\texorpdfstring{Skip\+White\+Space(char $\ast$$\ast$io\+Src\+Char\+Ptr, const Boolean in\+Stop\+At\+E\+O\+L=false)}{SkipWhiteSpace(char **ioSrcCharPtr, const Boolean inStopAtEOL=false)}}]{\setlength{\rightskip}{0pt plus 5cm}{\bf void} Skip\+White\+Space (
\begin{DoxyParamCaption}
\item[{char $\ast$$\ast$}]{io\+Src\+Char\+Ptr, }
\item[{const Boolean}]{in\+Stop\+At\+E\+OL = {\ttfamily false}}
\end{DoxyParamCaption}
)}\hypertarget{_c_p_string_utils_8hpp_a91dd2516988dceadf856069043cb904e}{}\label{_c_p_string_utils_8hpp_a91dd2516988dceadf856069043cb904e}


Definition at line 2733 of file C\+P\+String\+Utils.\+cpp.


\begin{DoxyCode}
2734 \{
2735     \textcolor{keywordflow}{if} (ioSrcCharPtr != nil && *ioSrcCharPtr != nil)
2736     \{
2737         \textcolor{keywordflow}{if} (inStopAtEOL)
2738         \{
2739             \textcolor{keywordflow}{while} ((**ioSrcCharPtr == \textcolor{charliteral}{' '} || **ioSrcCharPtr == \textcolor{charliteral}{'\(\backslash\)t'}) && **ioSrcCharPtr != \textcolor{charliteral}{'\(\backslash\)r'} && **
      ioSrcCharPtr != \textcolor{charliteral}{'\(\backslash\)n'})
2740             \{
2741                 *ioSrcCharPtr++;
2742             \}
2743         \}
2744         
2745         \textcolor{keywordflow}{else}
2746         \{
2747             \textcolor{keywordflow}{while} (**ioSrcCharPtr == \textcolor{charliteral}{' '} || **ioSrcCharPtr == \textcolor{charliteral}{'\(\backslash\)t'})
2748             \{
2749                 *ioSrcCharPtr++;
2750             \}
2751         \}
2752     \}
2753 \}
\end{DoxyCode}
