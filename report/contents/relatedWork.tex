\chapter{Related Work}

\section{Related Work}
In the section, we describe some application examples of formal verification techniques applied on security audit and assurance, such as hardware verification, software verification, and bug finding. It is important to learn from the success of others, in order to observe how the way model checking is being used effectively and what kind of effect it has contributed to the development process and the overall quality.

\paragraph{Software verification}
A. J{\"a}{\"a}skel{\"a}i \cite{jskelinen_et_al:OASIcs:2012:3589} verified a simple element in a safety-critical system, the implementation of the 2003 voting scheme in a SC3 level shutdown system, using CBMC and EBMC \cite{the_embc_user_manual}, another model checking tool developed by D. Kreoning, which is designed for hardware verification supporting input in Verilog and related formats. They had identify some potential problems and partial solutions with the help of model checking technique and the tools. The cited experiment is conducted in two stages: 1) working with the Pseudo code; and then 2) working with the actual implementation. First of all, they translated the Pseudo code into a simple C implementation, encoded all test cases as assertions and then verified with CBMC. Beginning with simple test cases allows a better understanding of the proprieties to be verified and also the verification tools. This helps moving forwards to develop some generic assertions for verifying more complicated properties. The fault seeding technique was also recommended for the user inexperienced with the bounded model checking tools as it helps to check whether a specification is possible to capture the desired intention. 

% D. Beyer \cite{Beyer:2014:SVG:2735050.2735079} performed a software verification in the Google App-Engine Cloud using an open-source verification framework CPA checkers

\paragraph{Error Detection}
K. Vorobyov \cite{Lipka2014} discussed the difference between two error detection techniques: 1) static program analysis, and 2) model checking, and described their experience. Model checking is able to compute the run-time states of the program without running the program. If the number of states is finite, then it is possible to perform an exhaustive analysis over all execution paths to check if a property holds. A program is claimed to be verified if its behaviours satisfied all properties in the specification. If a counter example is found, such that an execution path lead to a violation of any properties, then the program fails the verification. If the number of states is not finite, bounded model checking can still be applied by bounding the number of exploring states. Although this verification approach is not sound as bugs may exist beyond the bound, those bugs within the bound can still be identified.

Their experiment conducted with the help of CBMC by configuring it to focus on certain types of error only, such as array bounds, pointer checks and arithmetic over and underflow checks. It showed that CBMC resulted in a high accuracy rate, which is 97\% true positive detections, and found approximately 19\% more bugs although it required a longer execution time and more resources. They also suggested that insufficient unwinding was one of the reasons for false negative detections for CBMC.

J. Yang et al \cite{Yang:2006:UMC:1189256.1189259} demonstrated how to systematically test and find interesting errors in real file systems using model checking, while it is impossible to test such a complex file system in the tradition way. As there could be an exponential number of test cases of a complex file system, it is impractical to cover all of them. Moreover, the system will recover automatically once it crashes at any point during execution. Model checking makes use of some state-reducing techniques, hence, it is able to explore such vast state spaces efficiently.

The approach used for finding generic bugs is possible to be adopted in our project. They constructed two sets of checks throughout the test: 1) generic checks which could apply to any code run in the kernel, and 2) consistency checks which were the particular specifications for the properties of file systems. As a result, they were able to find 33 serious bugs in total.

\paragraph{Hunting the heartbleed bug}
M. Voelter \cite{Voelter:2015:TIS:2846696.2846698} made use of CBMC to identify the Heartbleed bug in OpenSSL. By using the modular language extensions to construct the specification, which is to create a message assigned to a non-deterministic data buffer, for CBMC-based verifications. This shows that most of the software security weakness caused by careless or wrong use of programming languages, such as the Heartbleed bug, are possible to be prevented under a formal software verification.
