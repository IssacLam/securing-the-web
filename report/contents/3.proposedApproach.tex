\chapter{Approach and Hypothesis} % and System Implementation}

\section{Identifying the Verification Scope}
Since s2n is not a stand-alone software package, it relies on the \textit{libcrypto} library, which is a general-purpose cryptography library, proved by OpenSSL. To study the structure of s2n, we construct a simple \textit{bash} program, shown in the Appendix~\ref{app:externalScanner}, to extract all the external function calls used in the s2n implementation, then examine and categorised each of them. The result, listed in the Appendix~\ref{app:externalFunctions}, shows that there are 112 different external function calls in total. Besides the \textit{libcrypto} library, s2n also stands on the standard C99 library and the system libraries. The architecture of s2n is outlined in the Figure~\ref{fig:s2nStructure} below.

\input{./contents/images/s2nStructure}

Consider that CBMC requires the actual coding to perform the syntactic analysis, it is impractical to include all the implementations of lower-layer libraries for the verification. Since this will enlarge the exploration states much beyond our scope, and also most of the system libraries and programming language libraries come along as complied binary files instead of the source files. In order to focus on verifying the implementation of s2n, we create a set of stubs to model the behaviour of those low-layer libraries (green highlight) for which s2n is standing on. The details of stubbing is be described in Section~\ref{subsec:stubbing}. 

\section{Choosing Suitable Approach}
Regarding the verification of a software package, most of the experience reports have not documented their verification approach or just verify a stand-alone function for demonstrating their proposed techniques. Hence, there is not much existing idea can be adopted to this project. We believe that there are different verification approaches with respect to various verification purposes and implementations of the software package. We will discuss three approaches we have considered as follows:

\paragraph{Function-based approach} is to verify every single functions independently, which does not take the function usage contracts, such as the execution environment and the order of function calls, into account. This approach is only suitable for verifying stand-alone functions that are supposed to handle all exceptions themselves. However, this approach will produce a large number of false alarms while applying to verify an object-oriented software, such as s2n. We constructed a \textit{bash} program to go through all the CBMC build-in checks over every s2n functions, the verification result is listed as follows:

\begin{table}[H]
\centering
\begin{threeparttable}
     \renewcommand\TPTminimum{\linewidth}
     \makebox[\linewidth]{%
    \begin{tabular}{| c | c | c | c | c | c | c | c | c |}
        \hline
        Property checked & BC \tnote{1} & DBZC \tnote{2} & PC \tnote{3} & MLC \tnote{4} & SOC \tnote{5} & UOC \tnote{6} & FOC \tnote{7} & Timeout \\
        \hline
        No. of alarms & 27 & 9 & 227 & 3 & 32 & 96 & 3 & 4  \\
        \hline
    \end{tabular}}
    \begin{multicols}{3}
    \begin{tablenotes}\footnotesize
        \item[1] Array Bounds Check
        \item[2] Divided By Zero Check
        \item[3] Pointer Check
        \item[4] Memory Leak Check
        \item[5] Signed Overflow Check
        \item[6] Unsigned Overflow Check
        \item[7] Float Overflow Check
    \end{tablenotes}
    \end{multicols}
    \caption{Number of false alarms generated by using function-based approach}
    \label{tab:my_label}
\end{threeparttable}
\end{table}

Since all function parameters supposed to be well prepared by and all error handling should be done by the caller functions in s2n according to the s2n development guide. These numbers of false alarms are generated because of the regardless of the function usages contracts. Therefore, this approach is not applicable and not reliable in this case as it requires a significant amount of human effort on reviewing each reports. 

\paragraph{Top-down module-based approach} is to verify the software package from the API level with respect to the function usage contracts by introducing test harnesses. This approach can minimise the number of false alarms being generated as well as the  verification effort. Since the verification environments are well prepared as same as the realistic usage scenarios, a bug must be present if a counterexample is produced, which means no false alarms will be generated. However, the work load can be extremely heavy for verifying such a bulky function call, which easily leads to a states explosion and an endless verification time. For example, we constructed a test harness for verifying the initialisation and termination of s2n, involved about 40 different sub-function calls, with the execution command as shown below:

\begin{listing}[ht]
\begin{minted}[frame=single, breaklines]{bash}
> cbmc -I ./s2n -I ./s2n/api -I ./s2n/libcrypto-build/openssl -I ./s2n/libcrypto-build/openssl/crypto -I ./s2n/libcrypto-build/openssl/crypto/engine -I ./s2n/libcrypto-build/openssl/include ./s2n-harness/top-down/s2n_test_harness.c ./s2n/utils/s2n_random.c ./s2n/crypto/s2n_drbg.c ./s2n/utils/s2n_mem.c ./s2n-lib/unistd.c ./s2n-lib/openssl/engine.c ./s2n-lib/fcntl.c ./s2n/utils/s2n_blob.c ./s2n/crypto/s2n_sequence.c ./s2n-lib/openssl/evp.c ./s2n-lib/pthread.c  --unwind 33 --unwindset s2n_get_urandom_data.0:65 --unwinding-assertions
\end{minted}
\inputminted[frame=single, breaklines, linenos, numbersep=5pt, tabsize=4, fontsize=\footnotesize, firstline=3]{c}{./contents/code/harnesses/s2n_test_harness.c}  %lastline=385, 
\caption{A test harness for verifying the initialisation and termination of s2n.}
\label{listing:s2n_test_harness}
\end{listing}

The above process requires more than 4 hours of verification time, and even is killed by terminal. Thus, it is also not an applicable approach for this case.

\paragraph{Bottom-up module-based approach} is to verify the software package each module as a time from the bottom level with respect to the function usage contracts.
Once a module is verified, it can be replaced by an over-approximated model in order to simplify the complexity of its caller functions. So that the verification is able to scale up for the entire software package. The details are described in the Section~\ref{chpt:verification}.

% For example, the following verification environment, as shown in the Figure~\ref{fig:oam} below, contains two huge loops \code{s2n_stuffer_skip_read} and \code{s2n_stuffer_skip_write}

% \begin{figure}[t]
%     \centering
%     \includegraphics[width=\textwidth]{./contents/images/s2n_stuffer_text.png}
%     \caption{Over Approximating Modules}
%     \label{fig:oam}
% \end{figure}

% \section{Methodology}
% % Proposed method.
% In this project, we will verify the above software packages with the help of CBMC. The verification process can be separated into two stages. We will first conduct a low-level verification on them to ensure the memory safety with those generic checks provided by CMBC: 1) array bounds checks, 2) division by zero checks, 3) pointer checks, 4) memory leak checks, and 5) arithmetic over- and underflow checks.
% % There are two different versions in order to support both signed types (e.g, int, long) and unsigned types (e.g, unsigned int, unsigned long). It will check whether there are any arithmetic over- and underflow on addition, subtraction, multiplication, division and negation operations. 

% Then, we will go though the implementation and perform an application-level verification to ensure the correctness of the implementation. According to the approaches that the packages based on, we study the behaviour of each function, and then extract the specifications of them. Each specification consists of a pre-condition and a post-condition. A pre-condition stating the property required of the input is the responsibility of the environment. Hence, it is modelled by an assumption to assume the property holds before function has been executed. A post-condition describes the property of the output established by the function which is modelled by an assertion. Then, we inject these assumptions and assertions into each functions in order to capture the functional properties of the two applications. If all the properties pass the verification, then we can conclude that they are implemented correctly and memory safe.

\section{Capturing the Function Usage Contracts}
\label{sec:cfuc}
After choosing a proper approach, we need to classify those functions into modules in order to study their usage contracts and be able to prepare appropriate harnesses for the verification. By scanning all the functions in s2n, we found there are 318 functions are implemented in 50 different C implementation files. However, there is no official document describing the usage contract of each functions. Only a brief usage guide \footnote{s2n Usage Guide: https://github.com/awslabs/s2n/blob/master/docs/USAGE-GUIDE.md} for the API functions is available on the s2n Github repository. Although, s2n is designed with readability in mind and most of the usages are guessable from the function name, the dependencies between functions are not clear, which is an obstacle to the verification. Thanks to the \textbf{Doxygen}\footnote{The Doxygen Main Page: http://www.stack.nl/~dimitri/doxygen/}, a documentation generator, which allows us to have an overview of all the functions and data structures in s2n. 

Besides analysing those dependency graphs generated by Doxygen, there are 31 unit test cases come along with the s2n repository, which are beneficial to the study of the function usage contracts as each of them is simulating the real scenario for using those functions. We can also transform those unit test cases into our testing harness by introducing non-determinism to such environments in order to extend the verification coverage, which is similar to the abstracting testing approach in \cite{Merz:2015:BGT:2837773.2837824}. All harnesses created in this verification are attached in Appendix~\ref{app:harnesses}.


% \section{Preparing the verification harness}
% \section{Specification Identification}


% \section{Safety properties check}

% \section{How big should k be?}

\section{Function Call Graphs Analysis}
As mentioned in the previous section, a set of dependency graphs, for example, function call graphs, are generated by using Doxygen. A clear overview of all functions help us determinate which function to begin with the verification and which functions are attainable or possible to be replaced by stubs. We use the analysis of \code{s2n_hash_test.c} as an example, which is shown in the Figure~\ref{fig:aeoffcga} below. The left hand side of the figure shows the original function call graph of \code{s2n_hash_test}. The green area indicates that those external function calls, such as \code{SHA1_Init}, \code{SHA1_Update}, \code{SHA1_Final}, etc, proved by the Common Crypto library of Max OS X, are considered as beyond our verification scope. Hence, they are replaced by a corresponding model of \code{CommonCrypto/CommonDigest} implementations. Moreover, the red area indicates the functions calls can be removed by non-determinism. As a result, the function dependencies are simplified as shown in the right hand side of the figure. The details of each unit test cases transformation are described in the Section~\ref{sec:vc}. 

\begin{figure}[t]
    \centering
    \includegraphics[width=\textwidth]{./contents/images/s2n_hash_test}
    \subfloat[The function call graph of s2n\_hash\_test.]{\hspace{.5\linewidth}}
    \subfloat[The simplified dependency of s2n\_hash\_harness.]{\hspace{.5\linewidth}}
    \caption{An example of function call graph analysis}
    \label{fig:aeoffcga}
\end{figure}

\section{Stubbing} \label{subsec:stubbing}
A stub method is used to model the behaviour of a targeted function, like its input and output behaviour, without performing the actual computation and it would return a simple and valid result, but may not be necessarily correct. It is useful for simplifying the verification processes. We continue the above case for showing how the models of functions, \code{SHA1_Init()} and \code{SHA1_Final()} be created. The following implementations of \code{SHA1_Init()} and \code{SHA1_Final()} are refered from the document of the Apple Open Source\footnote{The Open Source Apple: http://opensource.apple.com/}.

\begin{listing}[t]
\inputminted[frame=single, breaklines, linenos, numbersep=5pt, tabsize=4, fontsize=\footnotesize]{c}{./contents/code/stubs/CC_SHA1_Init.c} %firstline=359, lastline=385, 
\caption{The model of \code{CC_SHA1_Init()} implementation.}
% \label{listing: l}
\end{listing}

Consider that the assignments of the variable \code{context} (line 4-9) are not in our concern and these can be replaced by a non-deterministic assignment (line 15). The only interest of the function is the memory safety of the pointer, therefore an assertion is needed for ensuring the pointer is valid (line 12). Noted that the definition of a valid pointer is always debatable, sometimes it can refer to a pointer that must be pointing to a particular range of memory addresses. In this case, a valid pointer means that it is not pointing to \code{NULL}. 

\inputminted[frame=single, breaklines, linenos, numbersep=5pt, tabsize=4, fontsize=\footnotesize]{c}{./contents/code/stubs/CC_SHA1_Final.c}
\captionof{listing}{The model of \code{CC_SHA1_Final()} implementation.} 

Similar to modelling the \code{CC_SHA1_Init()} above, we are not interest in the actual computation of SHA1 (line 5-21), thus the method calls of \code{Encode()} and \code{SHA1Update()} can be simply skipped. However, we have to ensure the pointer of \code{digest} and \code{context} are valid (line 24-25) and also model the value changes to the variables (line 28 \& 31). 
% \unsure{if I will mention the change of memcpy/memset of CBMC lib} 
In order to make sure the memory access of an array must not exceed the allocated boundary, we model the behaviour by accessing the last byte of an array.


\section{Loop Bound Analysis}
\label{sec:lba}
% A Survey of Automated Techniques for Formal Software Verification
A appropriate bound is essential to bounded model checking, since it determines the number of loop unwinding, as mentioned in the Section ~\ref{unwinding}, as well as the coverage of the analysis. In this project, we are not only aim at finding bugs, but also proving the memory safety of the s2n implementation. Therefore, the Loop Unwinding Bound (LUB) is defined by the maximum number of loop iterations. Normally, such LUBs can be detected by CBMC automatically via a syntactic analysis of loop structures, for example, the left side of Table~\ref{table:lbd}. In some cases that the syntactic analysis fails, the right side of Table~\ref{table:lbd}, an iterative algorithm can be used to determine a suitable bound. To begin with guessing the number of loop iterations with the help of the unwinding assertions, the \code{--unwinding-assertions} option of CBMC, a violation can indicate any excess of the bound, hence a larger bound is needed \cite{4544862, ckl2004}. Note that, according to the CPROVER manual, the number of unwindings is defined by the number of backjumps. In the example below, the condition \code{i<10} has at most 11 times of evaluation for terminating the loop. Therefore, the UB of the loop should be 11, but not 10. 

\begin{table}[t]
\centering
\begin{minipage}[t]{.4\textwidth}
\centering
\begin{minted}[frame=single, breaklines, linenos, fontsize=\footnotesize]{c}
int depth=10;
for(int i=0; i<depth; i++) { 
    /* do something */ 
}
\end{minted}
\end{minipage}\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\begin{minted}[frame=single, breaklines, linenos, fontsize=\footnotesize]{c}
int depth=nondet_int();
__CPROVER_assume(depth>0 && depth<10);
for(int i=0; i<depth; i++) { 
    /* do something */ 
}
\end{minted}
\end{minipage}
\subfloat[A bound can be detected]{\hspace{.4\linewidth}}\hfill
\subfloat[A bound cannot be detected]{\hspace{.5\linewidth}}
\caption{An example of loop bound detection}
\label{table:lbd}
\end{table}

Apart from guessing the bound of loops, a more precise loop analysis can be preformed manually. By using the \code{--show-loops} option in CBMC, all loops in the included source files will be listed out with an unique identifier, as shown below. Then, the bounds of each loops can be determined by the usage study over a function caller graph. Each number of bounds can be specified for a particular loop by using \code{--unwindset} option.

\begin{minted}[frame=single, fontsize=\footnotesize]{bash}
Loop main.0:
  file demo.c line 5 function main
  
> cbmc --unwindset main.0:10 demo.c
\end{minted}

% This time is given by a bound on the maximum number of loop iterations and is usually computed via a simple syntactic analysis of loop structures. If the syntactic analysis fails, an iterative algorithm can be applied. First, a guess of the bound on the number of loop iterations is made. The loop is then unrolled up to this bound, as in Fig. 6, but with the assumption replaced by an assertion called an unwinding assertion. If the assertion is violated, there are paths in the program exceeding the bound, and a new guess for the bound is made [38], [83]. This method is applicable if the program (or its main loop body) has a run-time bound, which is highly desirable for many embedded applications.

\paragraph{do \dots while(0) loop syntax}
During the verification, we found that some \code{do |$\dots$| while(0)} loop macros are declared in the s2n implementation. This syntax are commonly used for convenience to declare a multi-statements macro correctly. The details is explained in the example below: Suppose we have two macros declared, where \code{A()} should be followed by \code{B()}:

\begin{table}[h]
\begin{minted}[frame=single, breaklines, linenos, fontsize=\footnotesize]{c}
#define F(x) A(x); B(x);
#define G(x) do { A(x); B(x); } while(0)
\end{minted}

\centering
\begin{minipage}[t]{.4\textwidth}
\centering
\begin{minted}[frame=single, breaklines, linenos, fontsize=\footnotesize]{c}
if(cond)
    F(x);

/* is equivalent to */
if(cond)
    A(x);
B(x);
\end{minted}
\end{minipage}\hfill
\begin{minipage}[t]{.5\textwidth}
\centering
\begin{minted}[frame=single, breaklines, linenos, fontsize=\footnotesize]{c}
if(cond)
    G(x);

/* is equivalent to */
if(cond) {
    A(x); B(x);
}
\end{minted}
\end{minipage}
\subfloat[Not work as expected]{\hspace{.4\linewidth}}\hfill
\subfloat[Work as expected]{\hspace{.5\linewidth}}
% \caption{An example of loop bound detection}
% \label{table:lbd}
\end{table}

A set of safety checks is declared using \code{do |$\dots$| while(0)} loop macros in s2n, listed in the Appendix~\ref{app:s2nSafety}, and these checks are applied over the entire s2n implementation. This syntax enlarged the workload of a loop bound analysis for filtering out these checking statements manually while using the \code{--show-loop} options in CBMC.


% Since this syntax looks a loop, but does not work as a loop, which becomes a disaster to the loop bound analysis. While a set of safety checks is declared using \code{do |$\dots$| while(0)} loop macros in s2n, listed in the Appendix~\ref{app:s2nSafety}, and these checks are applied over the entire s2n implementation. This implementation enlarged the workload of loop unwinding for duplicating the unnecessary copies of the loop body. Moreover, since the condition of the \code{do |$\dots$| while()} loop is \code{0}, 

% Sometimes the loop condition growth along with the usage, the unwinding assertion will never be enough.

% \code{while(1)}

% \code{while(c != '\0')}

\section{Simplifying Unnecessary Computations}
\label{sec:suc}

\section{Reviewing Verification Reports}