% A typical Related Work section follows a basic structure:
% It starts with few sentence overview of the general space, and
% A preview of areas that are particularly relevant and will be discussed in detail.
% The body consists of several paragraphs, each discussing a different relevant thread of research.
% The section ends with a paragraph summary of the paper's contributions over existing research.

\chapter{Background}

\section{Software Model Checking} \label{sec:mc}
Model Checking is an algorithmic technique to formal prove the correctness properties of the model of a state system \cite{Clarke:2000:MC:332656, Clarke:2008:BMC:1423535.1423536}. In other words, a model checking problem is defined as whether the states $s$ of a given model $M$ satisfies a property $P$ specified by a temporal logic formula, such that $M, s \models P$. The concept can be fully adapted to software verification considering that $M$ consists of \textit{states} and \textit{transitions}, and $P$ refer to a program and its specification respectively. By traversing all the reachable states exhaustively, the model checking algorithm is able to tell whether the program meet its specification or not if there is finite number of states. Once a violation is found on any execution path, an \textit{counterexample} can be generated accordingly. Model checking is capable to verify both \textit{safety} and \textit{liveness} properties of a software in different manner. Safety properties means nothing bad happens in the program execution, such as arithmetic overflow, buffer overflow, or NULL dereference, which can be verified by proving the unreachability of these states. Liveness properties means something good eventually happens. This can be proved by showing that a function fulfilled its responsibilities or the program will terminate at the end. This technique is precise by examining the states exhaustively, however, state explosion becomes a real problem. Although the combination of symbolic model checking with Binary Decision Diagrams (BDDs) slightly improved the state space, BDDs can still grow exponentially, which becomes the bottleneck of verification as the efficiency and capability are restricted.
% Model checking is able to compute the run-time states of the program without running the program. If the number of states is finite, then it is possible to perform an exhaustive analysis over all execution paths to check if a property holds. A program is claimed to be verified if its behaviours satisfied all properties in the specification. If a counter example is found, such that an execution path lead to a violation of any properties, then the program fails the verification. If the number of states is not finite, bounded model checking can still be applied by bounding the number of exploring states. Although this verification approach is not sound as bugs may exist beyond the bound, those bugs within the bound can still be identified.


\section{Bounded Model Checking} \label{sec:bmc}
In order to overcome the weakness of model checking and able to make use of it, Bounded Model Checking (BMC) based on Boolean Satisfiability (SAT) was proposed by A. Biere et al. \cite{biere2003bounded}. The basic idea of BMC is check the negation of a given property with in a given bounded length $k$ \cite{7371997}. Considering we have a model $M$ of a state machine, a property $P$, and a constant bound $k$ states, a BMC problem becomes whether a counterexample with at most $k$ state transitions exists satisfies a property $P$ for a given state machine $M$. This problem can be formulated as a SAT problem and hence be solved by a SAT solver \cite{1_sagiv_2015}. Hence, even if there is infinite number of states, BMC can still be applied by bounding the number of exploring states. Concerning the coverage of the verification, the bounded can lead to an unsound verification as bugs may exist beyond the bound. Nevertheless, all bugs within the bound are guaranteed to be identified. 

% Not done
\section{C Bounded Model Checker (CBMC)} \label{sec:cbmc}
CBMC \cite{the_cprover_user_manual} \cite{ckl2004} is a bounded model checker developed by D. Kroening et al. at Carnegie Mellon University. It utilizes a SAT solver in order to verify the software. It first translates a program into a static single assignment form without loops and function calls by bounding each loop with a number of executions and unwinding the loop to the bounded. Then, all variables can be renamed with states, ensuring that each variable is fresh and will only be assigned once. As a result, the program can be viewed as a set of constraints and be solved by using a SAT solver. Moreover, CBMC can also support the verification on dynamic allocations using malloc and free, buffer overflow, pointer safety, and also user-defined assertions. It has been widely used in a variety of applications, such as error explanation, verifying embedded programs, finding security bugs in windows binaries, etc.

% SAT-based Bounded Software Model Checking for Embedded Software: A Case Study
% High maturity of CBMC:
% CBMC can analyze target ANSI C code as it is and generate sound verification result (modulo user- given loop upper bounds). In contrast, other software model checkers targeting C code such as Blast [4] and CPAChecker [5] have limitations in analyzing complex target C code in practice (for example, Blast does not analyze array operations correctly [20]). In addition, CBMC has been developed more than 10 years and become more reliable than other research prototype tools of short development history.

% \section{Overview of the TLS/SSL}

\section{Overview of s2n}
s2n \cite{3_the_s2n_user_manual} is a lightweight and open-source implementation of the TLS/SSL protocols developed by the Amazon Security Labs. TLS/SSL protocols are cryptographic protocols providing the communication security over the network. s2n is designed to be simple, small, fast, and also with security as a priority. It is about 6,000 line of code ignoring tests, blank lines, and comments. It supports various version of the TLS/SSL protocols, such as SSLv3, TLS1.0-1.2, and also support different cipher suites.  


\input{contents/2.relatedWork}