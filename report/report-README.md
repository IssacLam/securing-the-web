# Error explanation and localization
- [ ] Error Explanation with Distance Metrics
- [ ] Automated Fault Localization for C Programs 
- [ ] Automated Program Debugging via Multiple Predicate Switching 
- [ ] Cause Clue Clauses: Error Localization using Maximum Satisfiability

# Concurrency
- [ ] Bounded Model Checking of Concurrent Programs
- [ ] Time-Bounded Analysis of Real-Time Systems
- [ ] Compositional Sequentialization of Periodic Programs
- [ ] Data Race Detection for Interrupt-Driven Programs via Bounded Model Checking
- [ ] CSeq: A Concurrency Pre-processor for Sequential C Verification Tools
- [ ] Regression-free Synthesis for Concurrency
- [ ] BBS: A Phase-Bounded Model Checker for Asynchronous Programs

# Equivalence Checking
- [ ] Partial Translation Verification for Untrusted Code-Generators
- [ ] Translation Validation for Stateflow to C
- [ ] Inference rules for proving the equivalence of recursive procedures
- [ ] An Efficient System-Level to RTL Verification Framework for Computation-Intensive Applications
- [ ] Equivalence Checking between Function Block Diagrams and C Programs Using HW-CBMC

# Cyper-physical Systems and Control
- [ ] Automated Domain-Specific C Verification with mbeddr
- [ ] Cyber/Physical Co-Verification for Developing Reliable Cyber-Physical Systems
- [ ] Runtime Verication for Ultra-Critical Systems
- [ ] Linking Functional Requirements and Software Verification
- [ ] A Framework for Analysing Driver Interactions with Semi-Autonomous Vehicles 
- [ ] Reachability Verification of Rhapsody Statecharts
- [ ] Applying Software Model Checking to PALS Systems

# Further Practical Applications and Experience Reports
- [X] Automated Verification for Functional and Relational Properties of Voting Rules
- [X] SAT-based Bounded Software Model Checking for Embedded Software: A Case Study
- [ ] (THREATS TO VALIDITY) Crowdsourcing Program Preconditions via a Classification Game
- [ ] How Verified is My Code? Falsification-Driven Verification
- [ ] CRUST: A Bounded Verifier for Rust
- [ ] Bridging the gap between test cases and requirements by abstract testing
- [ ] On the formal verification of component-based embedded operating systems
- [ ] Comparing Model Checking and Static Program Analysis: A Case Study in Error Detection Approaches
- [ ] Correctness of Sensor Network Applications by Software Bounded Model Checking 
- [ ] Formal Verification of Software for the Contiki Operating System Considering Interrupts 
- [ ] Software verification for TinyOS
- [ ] Model checking C source code for embedded systems
- [ ] Integrated Static Analysis for Linux Device Driver Verification
- [ ] Reducing False Positives by Combining Abstract Interpretation and Bounded Model Checking
- [ ] Efficient Elimination of False Positives Using Bounded Model Checking
- [ ] Configuration Lifting: Verification meets Software Configuration 
- [ ] Semiformal Verification of Embedded Software in Medical Devices Considering Stringent Hardware Constraints
- [ ] Formal Verification of a Flash Memory Device Driver – An Experience Report
- [ ] Concolic Testing of the Multi-sector Read Operation for Flash Memory File System 
- [ ] Unit Testing of Flash Memory Device Driver through a SAT-Based Model Checker
- [ ] A Comparative Study of Software Model Checkers as Unit Testing Tools: An Industrial Case Study
- [ ] Cross-Platform Verification Framework for Embedded Systems
- [ ] SMT-Based Bounded Model Checking for Embedded ANSI-C Software 
- [ ] Why does ASTRÉE scale up?
- [ ] Verifying Code and Its Optimizations: An Experience Report 
- [ ] Property-based Code Slicing for Efficient Verification of OSEK/VDX Operating Systems 
- [ ] Assertion Checking Using Dynamic Inference

# Test-vector generation
- [ ] Model-based testing of automotive software: some challenges and solutions
- [ ] Automatic Test Generation for Coverage Analysis of ERTMS Software 
- [ ] Automatic Test Generation for Coverage Analysis Using CBMC
- [ ] Using Bounded Model Checking for Coverage Analysis of Safety-Critical Software in an Industrial Setting
- [ ] Abstraction-guided Test Generation: A Case Study
- [ ] A Theory of Predicate-Complete Test Coverage and Generation
- [ ] Query-Driven Program Testing
- [ ] Masking Boundary Value Coverage: Effectiveness and Efficiency
- [ ] Test Generation for Large Automotive Models
- [ ] Combining Static Analysis and Constraint Solving for Automatic Test Case Generation
- [ ] Scaling Model Checking for Test Generation Using Dynamic Inference

# Worst-case execution time
- [ ] Scalable and Precise Refinement of Cache Timing Analysis via Model Checking
- [ ] Measurement-Based Timing Analysis
- [ ] Using a Model Checker to Determine Worst-case Execution Time
- [ ] Determining the Worst-Case Reaction Time of IEC 61499 Function Blocks
- [ ] Fully-automatic derivation of exact program-flow constraints for a tighter worst-case execution-time analysis

# Security
- [ ] Applied Quantitative Information Flow and Statistical Databases
- [ ] Quantifying Information Leaks in Software
- [ ] SAT-based Analysis and Quantification of Information Flow in Programs
- [ ] Abstract model counting: a novel approach for quantification of information leaks
- [ ] Parametric Verification of Address Space Separation
- [ ] Design, Implementation and Verification of an eXtensible and Modular Hypervisor Framework
- [ ] Secure Two-Party Computations in ANSI C
- [ ] Finding Security Vulnerabilities in a Network Protocol Using Parameterized Systems
- [ ] Academic tools and reallife bug finding in Win32
- [ ] Verifying security patches

# Others
- [ ] Proving Transaction and System-level Properties of Untimed SystemC TLM Designs 
- [ ] Induction-Based Formal Verification of SystemC TLM Designs
- [ ] Robustness Analysis of Floating-Point Programs by Self-Composition
- [ ] Incremental test case generation using bounded model checking: an application to automatic rating 
