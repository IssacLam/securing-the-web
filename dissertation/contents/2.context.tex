\chapter{Context and Rationale}

\paragraph{Clarification} The terms of soundness and completeness of a software verification technique often have various meanings in different papers. Sometimes soundness and completeness refer to an under-approximation and an over-approximation to a program behaviour respectively while sometimes they are defined in the opposite way. To be clearer, we will avoid using them throughout the report instead of using "no missing bugs" and "no false alarms" of a detection.  

\section{Overview of Software Verification}
\label{sec:osv}
Software verification is an important step in the software development life cycle, which is easily confused with software validation. It is questioning about "\textit{are we building the right product?}", while software verification cares about "\textit{are we building the product right?}" \cite{kung2008software}. In another word, we concern about \textbf{whether a system meets its specification}, including safety properties, liveness properties, concurrency properties, as well as functional and non-functional properties. These are the keys to ensuring quality and reliability of the software, especially for \textit{critical software}, such as safety-critical, security-critical, financial-critical. By analysing the system behaviour and detecting errors to minimise or prevent system failure. 

\input{contents/images/triangleModel}

% \subsection{A Triangle Model of Software Verification}
There are numerous verification techniques, based on formal or informal methods, available into to achieve the ultimate goal of software verification. These techniques can be divided into three categories according to their approach: \textit{Static Analysis}, \textit{Dynamic Analysis}, and \textit{Human-directed Analysis}. Although each of them has their focuses, strengths and weaknesses, their verification achievements can be concluded in three main properties: being automatic, not missing bugs, and excluding false alarms by M. Brain and D. Kroening \cite{TSVP}. These can also be visualised in a triangle model, which has been illustrated in  Figure~\ref{fig:tmsv} below. Since there always is a trade-off between the three proprieties, it becomes a weakness of such techniques. They can be considered as sitting at a corner of the triangle and climbing to the top of a pyramid while they are trying to tackle their weakness. We will discuss each of them with some  highlighted techniques as examples and the use of software verification in the following subsections.

% , while these existing techniques can be defined into six categories: 1) Static Analysis, 2) Abstract Interpretation, 3) Testing \& Symbolic Execution (Symex), 4) Model Checking, 5) Functional and 6) Deductive Verification. 

% is designed for a particular purpose. We discuss those techniques which are highly researched or presented recently.
% % A Survey of Automated Techniques for Formal Software Verification
% A survey that conducted by V. D'Silva et al. \cite{4544862} gave a detailed overview of three main automatic formal verification techniques, and brought out their strengths and weaknesses for applying to practical problems. The three techniques are: 1) Static Analysis, 2) Model Checking, and 3) Bounded Model Checking. 

\input{contents/2.1.softwareVerificationTechniques}

\input{contents/2.2.theUseOfSoftwareVerification}

\input{contents/2.relatedWork}